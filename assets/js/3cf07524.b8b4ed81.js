"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[4315],{4928:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var t=n(5893),i=n(1151);const s={sidebar_position:1,tags:["SpringSecurity","JWT","RefreshToken","Authentification","Autorisation","S\xe9curit\xe9Web","Spring","SpringBoot","Java","api"]},o="Spring Security : Authentification et Autorisation avec JWT",a={id:"Spring Framework/spring",title:"Spring Security : Authentification et Autorisation avec JWT",description:"Cet article est un retour d\u2019exp\xe9rience sur l'int\xe9gration de Spring Security dans une application Java bas\xe9e sur Spring Boot.",source:"@site/docs/Spring Framework/spring.md",sourceDirName:"Spring Framework",slug:"/Spring Framework/spring",permalink:"/docs/Spring Framework/spring",draft:!1,unlisted:!1,tags:[{label:"SpringSecurity",permalink:"/docs/tags/spring-security"},{label:"JWT",permalink:"/docs/tags/jwt"},{label:"RefreshToken",permalink:"/docs/tags/refresh-token"},{label:"Authentification",permalink:"/docs/tags/authentification"},{label:"Autorisation",permalink:"/docs/tags/autorisation"},{label:"S\xe9curit\xe9Web",permalink:"/docs/tags/securite-web"},{label:"Spring",permalink:"/docs/tags/spring"},{label:"SpringBoot",permalink:"/docs/tags/spring-boot"},{label:"Java",permalink:"/docs/tags/java"},{label:"api",permalink:"/docs/tags/api"}],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,tags:["SpringSecurity","JWT","RefreshToken","Authentification","Autorisation","S\xe9curit\xe9Web","Spring","SpringBoot","Java","api"]},sidebar:"tutorialSidebar",previous:{title:"Spring Framework",permalink:"/docs/category/spring-framework"},next:{title:"Angular",permalink:"/docs/category/angular"}},l={},c=[{value:"Focus sur l&#39;authentification",id:"focus-sur-lauthentification",level:2},{value:"Authentification Stateful",id:"authentification-stateful",level:3},{value:"Authentification Stateless",id:"authentification-stateless",level:3},{value:"Focus sur l&#39;autorisation",id:"focus-sur-lautorisation",level:2},{value:"L\u2019utilisation d\u2019un JWT",id:"lutilisation-dun-jwt",level:2},{value:"L&#39;utilisation d&#39;un refreshToken",id:"lutilisation-dun-refreshtoken",level:2},{value:"Comprendre le m\xe9canisme de l&#39;authentification et l&#39;autorisation",id:"comprendre-le-m\xe9canisme-de-lauthentification-et-lautorisation",level:2},{value:"Authentification d&#39;un utilisateur",id:"authentification-dun-utilisateur",level:3},{value:"Demander une ressource n\xe9cessitant l&#39;authentification",id:"demander-une-ressource-n\xe9cessitant-lauthentification",level:3},{value:"Les endpoints",id:"les-endpoints",level:3},{value:"Initialisation du projet",id:"initialisation-du-projet",level:3},{value:"Cr\xe9ation des \xe9num\xe9rations",id:"cr\xe9ation-des-\xe9num\xe9rations",level:3},{value:"Cr\xe9ation de l&#39;entit\xe9 User",id:"cr\xe9ation-de-lentit\xe9-user",level:3},{value:"Cr\xe9ation de l&#39;entit\xe9 RefreshToken",id:"cr\xe9ation-de-lentit\xe9-refreshtoken",level:3},{value:"Cr\xe9ation des Repositories User et RefreshToken",id:"cr\xe9ation-des-repositories-user-et-refreshtoken",level:3},{value:"D\xe9finition des payloads",id:"d\xe9finition-des-payloads",level:3},{value:"Impl\xe9mentation du Service JwtService",id:"impl\xe9mentation-du-service-jwtservice",level:3},{value:"Impl\xe9mentation du Service AuthenticationService",id:"impl\xe9mentation-du-service-authenticationservice",level:3},{value:"Impl\xe9mentation du Service RefreshTokenService",id:"impl\xe9mentation-du-service-refreshtokenservice",level:3},{value:"Gestion des exceptions",id:"gestion-des-exceptions",level:3},{value:"Cr\xe9ation des contr\xf4leurs Rest",id:"cr\xe9ation-des-contr\xf4leurs-rest",level:3},{value:"R\xe9ponses HTTP : 403 Forbidden vs 401 Unauthorized",id:"r\xe9ponses-http--403-forbidden-vs-401-unauthorized",level:3},{value:"G\xe9rer les erreurs d&#39;authentification avec AuthenticationEntryPoint",id:"g\xe9rer-les-erreurs-dauthentification-avec-authenticationentrypoint",level:3},{value:"G\xe9rer les erreurs d&#39;autorisation avec AccessDeniedHandler",id:"g\xe9rer-les-erreurs-dautorisation-avec-accessdeniedhandler",level:3},{value:"Filtrer les requ\xeates HTTP",id:"filtrer-les-requ\xeates-http",level:3},{value:"Configuration de Spring Security",id:"configuration-de-spring-security",level:3},{value:"D\xe9monstration de l&#39;application",id:"d\xe9monstration-de-lapplication",level:2},{value:"Conclusion",id:"conclusion",level:2}];function u(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{id:"spring-security--authentification-et-autorisation-avec-jwt",children:"Spring Security : Authentification et Autorisation avec JWT"}),"\n",(0,t.jsx)(r.p,{children:"Cet article est un retour d\u2019exp\xe9rience sur l'int\xe9gration de Spring Security dans une application Java bas\xe9e sur Spring Boot."}),"\n",(0,t.jsx)(r.p,{children:"Cet article n'est pas une formation ou un cours complet de Spring Security, mais plut\xf4t un guide visant \xe0 vous aider \xe0 mettre en place une authentification bas\xe9e sur JWT (JSON WEB TOKEN). Il couvre certains aspects n\xe9cessaires de la s\xe9curit\xe9 informatique, ainsi que des d\xe9finitions et des principes qui vous aideront \xe0 vous familiariser avec Spring Security."}),"\n",(0,t.jsx)(r.p,{children:"Dans cet article, nous allons cr\xe9er un exemple concret d'API REST bas\xe9 sur Spring boot qui couvre les bases essentielles d'authentification et d'autorisation en Spring Security avec JWT."}),"\n",(0,t.jsx)(r.p,{children:"Spring Security est un Framework qui offre une couche de s\xe9curit\xe9 pour les applications Java Spring, en particulier avec Spring Boot. Il permet de configurer Spring pour pr\xe9venir les attaques en ayant recours \xe0 tr\xe8s peu, voire \xe0 aucune configuration."}),"\n",(0,t.jsx)(r.p,{children:"La s\xe9curit\xe9 des applications Web de mani\xe8re g\xe9n\xe9rale est tr\xe8s importante et \xe0 ne pas n\xe9gliger, en tant que d\xe9veloppeur informatique, il est essentiel d'avoir un minimum de comp\xe9tences en mati\xe8re de s\xe9curit\xe9 pour garantir la protection des donn\xe9es sensibles."}),"\n",(0,t.jsx)(r.h1,{id:"d\xe9finitions-et-concepts-de-bases",children:"D\xe9finitions et concepts de bases"}),"\n",(0,t.jsx)(r.p,{children:"Notre objectif est de contr\xf4ler l'acc\xe8s \xe0 une API REST Spring Boot en mettant en place un m\xe9canisme de s\xe9curit\xe9. Le contr\xf4le d'acc\xe8s comprend g\xe9n\xe9ralement deux \xe9tapes distinctes : l'authentification et l'autorisation."}),"\n",(0,t.jsx)(r.p,{children:"Nous allons faire appel \xe0 Spring Security pour controler l'acc\xe8s \xe0 notre API, mais voyons d'abord la diff\xe9rence entre l'authentification et l'autorisation."}),"\n",(0,t.jsx)(r.h2,{id:"focus-sur-lauthentification",children:"Focus sur l'authentification"}),"\n",(0,t.jsx)(r.p,{children:"L'utilisateur doit \xeatre authentifi\xe9 avant d'acc\xe9der aux diff\xe9rentes ressources de l'application. Il existe plusieurs mani\xe8res de faire l'authentification dans notre cas, nous devons mettre en place un m\xe9canisme permettant de fournir \xe0 l'utilisateur une cl\xe9 d'authentification, qu'il devra pr\xe9senter \xe0 chaque interaction avec le serveur n\xe9cessitant un acc\xe8s s\xe9curis\xe9."}),"\n",(0,t.jsxs)(r.p,{children:["Il existe diff\xe9rentes formes d'authentification, dont l'authentification basique bas\xe9e sur le login et le mot de passe. Pour notre future API REST, nous allons choisir une approche ",(0,t.jsx)(r.strong,{children:"Stateless"}),", o\xf9 l'API n'enregistrera pas l'\xe9tat de l'utilisateur entre les requ\xeates. Cependant, il est important de noter que d'autres applications peuvent utiliser un syst\xe8me d'authentification ",(0,t.jsx)(r.strong,{children:"Stateful"}),", o\xf9 l'\xe9tat de l'utilisateur est conserv\xe9 entre les requ\xeates, par exemple en utilisant des sessions."]}),"\n",(0,t.jsx)(r.h3,{id:"authentification-stateful",children:"Authentification Stateful"}),"\n",(0,t.jsxs)(r.p,{children:["L'authentification ",(0,t.jsx)(r.strong,{children:"Stateful"})," repose sur l'utilisation de sessions, qui repr\xe9sentent une p\xe9riode de temps pendant laquelle un utilisateur est authentifi\xe9 et peut interagir avec le site. Lorsque l'utilisateur se connecte pour la premi\xe8re fois via son navigateur en utilisant ses identifiants, le serveur ouvre une session avec un ID unique et une dur\xe9e de validit\xe9 pour repr\xe9senter l'utilisateur connect\xe9. Pour maintenir l'\xe9tat de la session c\xf4t\xe9 client, le serveur envoie un cookie contenant l'identifiant de session au navigateur de l'utilisateur. Le navigateur stocke ensuite ce cookie et l'envoie automatiquement au serveur avec chaque requ\xeate ult\xe9rieure pour maintenir la continuit\xe9 de la session."]}),"\n",(0,t.jsx)(r.p,{children:"Lorsque le serveur re\xe7oit une requ\xeate avec le cookie, il fait la correspondance entre l'identifiant de session et les donn\xe9es de session associ\xe9es. Cela lui permet de v\xe9rifier si l'utilisateur est toujours authentifi\xe9 et si la session est toujours valide."}),"\n",(0,t.jsx)(r.p,{children:"Ce qu'il faut retenir de tout \xe7a :"}),"\n",(0,t.jsxs)(r.p,{children:["Si les donn\xe9es de la session sont enregistr\xe9s c\xf4t\xe9 serveur d'authentification et qu'une copie est enregistr\xe9e c\xf4t\xe9 client sous forme de cookies , alors cela correspond \xe0 une authentification de type ",(0,t.jsx)(r.strong,{children:"Stateful."})," Cette approche permet de maintenir un \xe9tat de session du c\xf4t\xe9 du serveur."]}),"\n",(0,t.jsx)(r.p,{children:"Ce type d'authentification ne sera pas impl\xe9ment\xe9 dans cet article."}),"\n",(0,t.jsx)(r.h3,{id:"authentification-stateless",children:"Authentification Stateless"}),"\n",(0,t.jsx)(r.p,{children:"L'API n'a pas besoin de maintenir la session c\xf4t\xe9 serveur. Comme mentionn\xe9 pr\xe9c\xe9demment, les donn\xe9es de session sont enregistr\xe9es dans un jeton d'authentification qui est envoy\xe9 au client une fois qu'il est correctement authentifi\xe9. Le client utilise ensuite ce jeton pour l'associer \xe0 chaque requ\xeate envoy\xe9e au serveur. Cela correspond \xe0 une authentification de type Stateless."}),"\n",(0,t.jsx)(r.p,{children:"Il n'est pas n\xe9cessaire de stocker le jeton c\xf4t\xe9 serveur. Nous explorerons plus en d\xe9tail ult\xe9rieurement comment le serveur peut v\xe9rifier et valider ce jeton d'acc\xe8s."}),"\n",(0,t.jsx)(r.h2,{id:"focus-sur-lautorisation",children:"Focus sur l'autorisation"}),"\n",(0,t.jsx)(r.p,{children:"L'autorisation est bas\xe9e sur les r\xf4les, ce qui signifie qu'apr\xe8s l'authentification, nous pouvons contr\xf4ler qui a le droit d'effectuer certaines t\xe2ches. Par exemple, un utilisateur administrateur peut acc\xe9der et modifier les donn\xe9es, tandis qu'un utilisateur visiteur ne peut que les lire. Il est important de souligner que cette autorisation peut \xeatre plus granulaire, permettant de d\xe9finir les droits de lecture sur des donn\xe9es sp\xe9cifiques plut\xf4t que sur l'ensemble des donn\xe9es."}),"\n",(0,t.jsx)(r.h2,{id:"lutilisation-dun-jwt",children:"L\u2019utilisation d\u2019un JWT"}),"\n",(0,t.jsx)(r.p,{children:"Un JSON Web Token (JWT) est en effet un objet JSON qui contient des paires cl\xe9-valeur. Il est g\xe9n\xe9ralement encod\xe9 et repr\xe9sent\xe9 sous forme d'une cha\xeene de caract\xe8res. Dans le contexte de l'authentification, un JWT peut contenir des informations telles qu'un username, une liste de droits d'acc\xe8s et une date d'expiration. Lorsqu'un JWT contenant ces informations est inclus dans une requ\xeate, il est possible d'indiquer \xe0 Spring Security d'utiliser ce JWT comme preuve d'authentification."}),"\n",(0,t.jsx)(r.p,{children:"Le JWT encapsule les informations de session de l'utilisateur ainsi que d'autres informations suppl\xe9mentaires. Pour structurer ces informations, le JWT est compos\xe9 de trois parties distinctes (header, payload, signature) qui sont encod\xe9es en base64URL et s\xe9par\xe9es par des points (.) :"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Header"})," : c'est la premi\xe8re partie d'un JWT, elle contient des informations sur le type de jeton et l'algorithme de signature utilis\xe9 : \"alg\" : l'algorithme de signature utilis\xe9 pour signer le jeton \"typ\" : le type de jeton"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Payload"}),' : contient les revendications appel\xe9es "Claims" qui repr\xe9sentent les informations sp\xe9cifiques \xe0 l\'utilisateur et aux m\xe9tadonn\xe9es suppl\xe9mentaires. Il existe trois type de revendications :']}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Revendications enregistr\xe9es (Registered Claims)"}),' : Ce sont des revendications pr\xe9d\xe9finies par le standard JWT qui ne sont pas obligatoires, mais recommand\xe9es pour repr\xe9senter des informations couramment utilis\xe9es. Par exemple, "iss" (\xe9metteur), "sub" (sujet), "exp" (date d\'expiration) et "iat" (date de cr\xe9ation).']}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Revendications priv\xe9es (Private Claims)"})," : Ce sont des revendications personnalis\xe9es d\xe9finies par l'\xe9metteur et le destinataire du jeton pour \xe9changer des informations sp\xe9cifiques \xe0 leur application."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Revendications publiques (Public Claims)"})," : Ce sont des revendications personnalis\xe9es qui sont d\xe9finies dans des registres publics pour assurer l'interop\xe9rabilit\xe9 entre diff\xe9rentes applications."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Signature"})," : la signature est utilis\xe9e pour garantir que le jeton n'a pas \xe9t\xe9 modifi\xe9 par des tiers non autoris\xe9s. La signature est calcul\xe9e en utilisant le Header + les Claims encod\xe9es en Base64Url + une cl\xe9 secr\xe8te (dans le cas d'un algorithme de signature sym\xe9trique) ou une paire de cl\xe9s (dans le cas d'un algorithme de signature asym\xe9trique)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"La signature est ajout\xe9e en tant que troisi\xe8me partie du JWT, \xe9galement encod\xe9e en Base64Url."}),"\n",(0,t.jsxs)(r.p,{children:["En r\xe9sum\xe9, la combinaison de ces trois parties ",(0,t.jsx)(r.strong,{children:"Header.Payload.Signature"})," forme le JWT. Voici un exemple :"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"image-20230716224835601",src:n(8699).Z+"",width:"510",height:"175"})}),"\n",(0,t.jsx)(r.p,{children:"Cette structure permet de transporter les informations n\xe9cessaires de mani\xe8re s\xe9curis\xe9e et compacte dans le JWT, sans avoir besoin de stocker des informations de session c\xf4t\xe9 serveur."}),"\n",(0,t.jsx)(r.h2,{id:"lutilisation-dun-refreshtoken",children:"L'utilisation d'un refreshToken"}),"\n",(0,t.jsx)(r.p,{children:"Le JWT a une dur\xe9e de validit\xe9 relativement courte, pour garantir une s\xe9curit\xe9 maximale, Cependant s'il est expir\xe9 l'utilisateur doit s'authentifier \xe0 nouveau et donc re saisir son login et son mot de passe pour demander un autre JWT. Le refreshToken vient r\xe9soudre ce probl\xe8me, il peut \xeatre utilis\xe9 pour demander un nouveau jeton d'acc\xe8s sans n\xe9cessiter de nouvelles informations d'identification de la part de l'utilisateur."}),"\n",(0,t.jsx)(r.p,{children:"Le refreshToken est tout simplement un jeton de rafraichissement qui a une dur\xe9e de validit\xe9 plus longue que le jeton d'acc\xe8s. Il est utilis\xe9 sp\xe9cifiquement pour obtenir un nouveau jeton d'acc\xe8s lorsque le jeton actuel expire. Le jeton de rafra\xeechissement est g\xe9n\xe9ralement associ\xe9 \xe0 une session utilisateur persistante et est stock\xe9 de mani\xe8re s\xe9curis\xe9e c\xf4t\xe9 serveur."}),"\n",(0,t.jsx)(r.p,{children:"Voici comment nous allons mettons cela en pratique :"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"Lorsque l'utilisateur se connecte et r\xe9ussit l'authentification, le serveur g\xe9n\xe8re un jeton d'acc\xe8s et un jeton de rafra\xeechissement et les envoie au client(application ou service) et le jeton de rafra\xeechissement est stock\xe9 c\xf4t\xe9 serveur."}),"\n",(0,t.jsx)(r.li,{children:"Lorsque le jeton d'acc\xe8s expire, au lieu de demander \xe0 l'utilisateur de se reconnecter avec ses informations d'identification, le client envoie le jeton de rafra\xeechissement au serveur."}),"\n",(0,t.jsx)(r.li,{children:"Le serveur v\xe9rifie si le jeton de rafra\xeechissement est valide et correspond \xe0 un utilisateur connect\xe9. Si c'est le cas, le serveur g\xe9n\xe8re un nouveau jeton d'acc\xe8s avec une dur\xe9e de validit\xe9 limit\xe9e et le renvoie au client."}),"\n",(0,t.jsx)(r.li,{children:"Le client utilise alors ce nouveau jeton d'acc\xe8s pour acc\xe9der aux ressources prot\xe9g\xe9es."}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Le refreshToken permet de renforcer la s\xe9curit\xe9 de l'ensemble du processus d'authentification et d'autorisation. Par exemple, si le client souhaite se d\xe9connecter d'une session, il lui suffit de r\xe9voquer le refreshToken associ\xe9 au JWT, ce qui forcera le client \xe0 demander \xe0 l'utilisateur de s'authentifier lorsque le JWT expire."}),"\n",(0,t.jsx)(r.p,{children:"Un autre cas tr\xe8s pratique est lorsqu'il y a un changement dans les autorisations d'un utilisateur. Dans ce cas, nous pouvons r\xe9voquer tous les refresh tokens associ\xe9s aux sessions ouvertes de l'utilisateur, ce qui forcera aussi le client \xe0 demander \xe0 l'utilisateur de s'authentifier \xe0 nouveau lorsque le JWT expire. Ainsi, le client pourra obtenir les nouvelles autorisations."}),"\n",(0,t.jsx)(r.h1,{id:"comprendre-larchitecture-de-spring-security",children:"Comprendre l'architecture de Spring Security"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{src:n(6424).Z+"",width:"1325",height:"799"})}),"\n",(0,t.jsx)(r.p,{children:"En me basant sur le diagramme ci-dessus, je vais vous expliquer l'architecture de Spring Security et son mode de fonctionnement."}),"\n",(0,t.jsx)(r.p,{children:"Spring Security repose sur un concept central pour le traitement des requ\xeates HTTP : les filtres. Il utilise une cha\xeene de filtres pour intercepter les requ\xeates entrantes, ce qui permet de mettre en \u0153uvre la gestion de l'authentification, de l'autorisation et de la protection contre les attaques."}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"DelegatingFilterProxy"})," est une impl\xe9mentation de l'interface jakarta.servlet.Filter fournie par le framework Spring pour int\xe9grer les filtres de servlet dans l'infrastructure de Spring."]}),"\n",(0,t.jsxs)(r.p,{children:["Techniquement, lorsqu'on utilise des filtres de servlet, on doit \xe9videmment les d\xe9clarer en tant que classe de filtre dans notre configuration ou web.xml, sinon le conteneur de servlet les ignorera. Le ",(0,t.jsx)(r.strong,{children:"DelegatingFilterProxy"})," de Spring assure le lien entre web.xml et le contexte de l'application. Il agit comme un point d'entr\xe9e unique pour les filtres de servlet dans une application web bas\xe9e sur Spring"]}),"\n",(0,t.jsxs)(r.p,{children:["Lorsque ",(0,t.jsx)(r.strong,{children:"DelegatingFilterProxy"})," re\xe7oit une requ\xeate, il d\xe9l\xe8gue la responsabilit\xe9 du traitement \xe0 un filtre sp\xe9cifique configur\xe9 dans la configuration de l'application."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"FilterChainProxy"})," est une classe sp\xe9cifique \xe0 Spring Security qui g\xe8re la cha\xeene de filtres de s\xe9curit\xe9 dans une application Spring Security. Elle agit comme un filtre principal qui intercepte toutes les requ\xeates entrantes et les achemine \xe0 travers une cha\xeene de filtres de s\xe9curit\xe9 configur\xe9s."]}),"\n",(0,t.jsxs)(r.p,{children:["La configuration des filtres de s\xe9curit\xe9 dans ",(0,t.jsx)(r.strong,{children:"FilterChainProxy"})," se fait g\xe9n\xe9ralement \xe0 l'aide du bean ",(0,t.jsx)(r.strong,{children:"SecurityFilterChain"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"SecurityFilterChain"})," permet de configurer pr\xe9cis\xe9ment les r\xe8gles de s\xe9curit\xe9 en sp\xe9cifiant quels filtres doivent \xeatre appliqu\xe9s dans quel ordre pour chaque chemin d'acc\xe8s ou URL sp\xe9cifique. Cela offre une grande flexibilit\xe9 pour adapter les r\xe8gles de s\xe9curit\xe9 en fonction des besoins sp\xe9cifiques de l'application."]}),"\n",(0,t.jsxs)(r.p,{children:["Dans notre exemple, nous allons modifier la configuration de Spring en fournissant une instance de ",(0,t.jsx)(r.strong,{children:"SecurityFilterChain"})," qui r\xe9pond aux exigences de s\xe9curit\xe9 de notre API."]}),"\n",(0,t.jsx)(r.p,{children:"Spring nous fournit une liste de filtres qui sont ex\xe9cut\xe9s dans un certain ordre. Il n'est pas n\xe9cessaire de conna\xeetre tous les filtres impl\xe9ment\xe9s par Spring, car ce n'est pas l'objectif de cet article. Cependant, vous pouvez consulter la documentation officielle pour obtenir plus de d\xe9tails \xe0 ce sujet. N\xe9anmoins, je vais expliquer quelques filtres que j'ai inclus dans l'architecture."}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"UsernamePasswordAuthenticationFilter"})," : Son r\xf4le est de g\xe9rer l'authentification bas\xe9e sur un formulaire. Plus pr\xe9cis\xe9ment, ce filtre est responsable de l'analyse d'une soumission de formulaire d'authentification contenant un couple nom d'utilisateur/mot de passe. Pour notre syst\xe8me d'authentification stateless, ce filtre n'est pas utile et peut \xeatre exclu afin de se concentrer sur le filtre ",(0,t.jsx)(r.strong,{children:"JwtAuthenticationFilter"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"JwtAuthenticationFilter"})," : C'est un filtre personnalis\xe9 qui est responsable de la validation des JWT. Il permet d'intercepter chaque requ\xeate HTTP, v\xe9rifier la pr\xe9sence d'un JWT, extraire puis le valider avant de passer la main aux autres filtres de la cha\xeene."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"ExceptionTranslationFilter"})," : C'est un filtre important dans Spring Security. Son r\xf4le principal est de g\xe9rer les exceptions li\xe9es \xe0 la s\xe9curit\xe9 qui se produisent lors du traitement des requ\xeates et de les traduire en r\xe9ponses HTTP appropri\xe9es. Par exemple, il peut renvoyer une r\xe9ponse 403 (interdit) si une exception de type ",(0,t.jsx)(r.strong,{children:"AccessDeniedException"})," se produit."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"AuthorizationFilter"})," (FilterSecurityInterceptor - d\xe9pr\xe9ci\xe9 depuis la version 5.5) : Il effectue les v\xe9rifications d'autorisation bas\xe9es sur les r\xf4les de l'utilisateur connect\xe9 (nous en verrons plus dans la pratique). \xc0 noter que ce filtre est configur\xe9 avec un ",(0,t.jsx)(r.strong,{children:"AccessDecisionManager"})," qui prend la d\xe9cision finale concernant l'autorisation d'une requ\xeate en se basant sur les attributs de s\xe9curit\xe9 et les d\xe9cisions prises par les ",(0,t.jsx)(r.strong,{children:"AccessDecisionVoters"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"UsernamePasswordAuthenticationToken"})," est une impl\xe9mentation de l'interface ",(0,t.jsx)(r.strong,{children:"Authentication"})," sp\xe9cifique \xe0 l'authentification bas\xe9e sur le nom d'utilisateur et le mot de passe. Il h\xe9rite de la classe abstraite ",(0,t.jsx)(r.strong,{children:"AbstractAuthenticationToken"})," et repr\xe9sente l'identit\xe9 de l'utilisateur \xe0 authentifier."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Authentication"})," encapsule les d\xe9tails de l'authentification tels que le nom d'utilisateur, les r\xf4les, les autorisations, etc."]}),"\n",(0,t.jsxs)(r.p,{children:["Voici \xe0 quoi ressemble l'objet ",(0,t.jsx)(r.strong,{children:"Authentication"})," :"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-json",children:'{\r\n    "authorities": [\r\n        {\r\n            "authority": "UPDATE_PRIVILEGE"\r\n        },\r\n        {\r\n            "authority": "DELETE_PRIVILEGE"\r\n        },\r\n        {\r\n            "authority": "READ_PRIVILEGE"\r\n        },\r\n        {\r\n            "authority": "WRITE_PRIVILEGE"\r\n        },\r\n        {\r\n            "authority": "ROLE_ADMIN"\r\n        }\r\n    ],\r\n    "details": null,\r\n    "authenticated": true,\r\n    "principal": {\r\n        "id": 1,\r\n        "firstname": "mossaab",\r\n        "lastname": "frifita",\r\n        "email": "frifita1@gmail.com",\r\n        "password": "$2a$10$laYzRwXuWpueMZyJfxmOu.MsG9wAaoKjnbuoPW3xvZ9za2G.IwCfm",\r\n        "role": "ADMIN",\r\n        "enabled": true,\r\n        "accountNonLocked": true,\r\n        "accountNonExpired": true,\r\n        "credentialsNonExpired": true,\r\n        "authorities": [\r\n            {\r\n                "authority": "UPDATE_PRIVILEGE"\r\n            },\r\n            {\r\n                "authority": "DELETE_PRIVILEGE"\r\n            },\r\n            {\r\n                "authority": "READ_PRIVILEGE"\r\n            },\r\n            {\r\n                "authority": "WRITE_PRIVILEGE"\r\n            },\r\n            {\r\n                "authority": "ROLE_ADMIN"\r\n            }\r\n        ],\r\n        "username": "frifita1@gmail.com"\r\n    },\r\n    "credentials": null,\r\n    "name": "frifita1@gmail.com"\r\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"SecurityContextHolder"})," est utilis\xe9 pour acc\xe9der au ",(0,t.jsx)(r.strong,{children:"SecurityContext"})," et effectuer des op\xe9rations sur celui-ci, telles que la r\xe9cup\xe9ration de l'objet ",(0,t.jsx)(r.strong,{children:"Authentication"}),", la d\xe9finition d'un nouvel objet ",(0,t.jsx)(r.strong,{children:"Authentication"})," ou la suppression du contexte de s\xe9curit\xe9. Son objectif est de repr\xe9senter l'\xe9tat d'authentification de l'utilisateur."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"AuthenticationManger"})," est le point d'entr\xe9e du processus d'authentification. son r\xf4le est d'authentifier l'utilisateur \xe9metteur de la requ\xeate. C'est une interface qui poss\xe8de une seule m\xe9thode ",(0,t.jsx)(r.strong,{children:"authenticate"})," qui renvoie un objet ",(0,t.jsx)(r.strong,{children:"Authentication"})]}),"\n",(0,t.jsxs)(r.p,{children:["L'impl\xe9mentation par d\xe9faut fournie par Spring est la classe ",(0,t.jsx)(r.strong,{children:"ProviderManager"}),". Elle est responsable de l'orchestration des diff\xe9rents ",(0,t.jsx)(r.strong,{children:"AuthenticationProviders"})," utilis\xe9s pour valider une demande d'authentification. Lorsqu'une demande d'authentification est re\xe7ue, le ProviderManager it\xe8re sur la liste des AuthenticationProviders configur\xe9s et d\xe9l\xe8gue la responsabilit\xe9 de l'authentification \xe0 l'un d'entre eux. Le ProviderManager tente les diff\xe9rents providers (par exemple LDAP, base de donn\xe9es) jusqu'\xe0 ce qu'une authentification r\xe9ussie soit obtenue ou jusqu'\xe0 ce qu'il n'y ait plus de providers \xe0 essayer."]}),"\n",(0,t.jsxs)(r.p,{children:["Un ",(0,t.jsx)(r.strong,{children:"Provider"})," est une impl\xe9mentation de ",(0,t.jsx)(r.strong,{children:"AuthenticationProvider"})," qui d\xe9finit comment l'utilisateur doit \xeatre authentifi\xe9. Dans notre exemple, nous allons utiliser le ",(0,t.jsx)(r.strong,{children:"DAOAuthenticationProvider"})," fourni par Spring."]}),"\n",(0,t.jsxs)(r.p,{children:["Sachez que vous pouvez cr\xe9er votre propre fournisseur en fournissant simplement une impl\xe9mentation de l'interface ",(0,t.jsx)(r.strong,{children:"AuthenticationProvider"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"DAOAuthenticationProvider"})," est utilis\xe9 pour l'authentification bas\xe9e sur le couple nom d'utilisateur/mot de passe stock\xe9 dans une base de donn\xe9es. Il utilise ",(0,t.jsx)(r.strong,{children:"UserDetailsService"})," pour r\xe9cup\xe9rer les informations de l'utilisateur et ",(0,t.jsx)(r.strong,{children:"PasswordEncoder"})," pour comparer le mot de passe fourni avec celui stock\xe9."]}),"\n",(0,t.jsxs)(r.p,{children:["Si le provider  a r\xe9ussi \xe0 authentifier l'utilisateur, il retourne un objet ",(0,t.jsx)(r.strong,{children:"Authentication"}),". En cas d'\xe9chec (nom d'utilisateur ou mot de passe invalide), une ",(0,t.jsx)(r.strong,{children:"AuthenticationException"})," est lev\xe9e."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"AuthenticationEntryPoint"})," c'est un gestionnaire des erreurs d'authentification, on peut dire que c'est un handler en quelque sorte. Il est responsable de la gestion des exceptions li\xe9es \xe0 l'authentification et de la cr\xe9ation des r\xe9ponses appropri\xe9es \xe0 renvoyer au client lorsque ces exceptions se produisent. Il peut \xeatre configur\xe9 pour renvoyer diff\xe9rentes r\xe9ponses d'erreur personnalis\xe9es en fonction du type et du code d'erreur. Par exemple le code HTTP 401 (unauthorized) ou 403 (Forbidden)"]}),"\n",(0,t.jsx)(r.p,{children:"Faisons un petit r\xe9capitulatif pour vous aider \xe0 m\xe9moriser ce qu'on vient d'expliquer :"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{src:n(6687).Z+"",width:"201",height:"427"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"UserDetailsService"})," est une interface qui propose une m\xe9thode ",(0,t.jsx)(r.strong,{children:"loadByUsername"})," pour r\xe9cup\xe9rer un utilisateur par son nom d'utilisateur. Elle retourne un objet impl\xe9mentant l'interface ",(0,t.jsx)(r.strong,{children:"UserDetails"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["Spring Security nous propose la classe ",(0,t.jsx)(r.strong,{children:"User"}),", qui est une impl\xe9mentation par d\xe9faut de l'interface ",(0,t.jsx)(r.strong,{children:"UserDetails"}),". Comme vous pouvez le voir sur le diagramme, la classe ",(0,t.jsx)(r.strong,{children:"User"})," fournit des propri\xe9t\xe9s importantes telles que le nom d'utilisateur, le mot de passe et les autorit\xe9s n\xe9cessaires pour la v\xe9rification des autorisations lors du processus d'authentification."]}),"\n",(0,t.jsxs)(r.p,{children:["Il est possible de surcharger la classe ",(0,t.jsx)(r.strong,{children:"User"})," ou d'impl\xe9menter directement l'interface ",(0,t.jsx)(r.strong,{children:"UserDetails"})," si l'on souhaite ajouter des informations suppl\xe9mentaires sp\xe9cifiques \xe0 notre application. Ainsi, pour que notre classe utilisateur soit un utilisateur de Spring Security, elle doit soit \xe9tendre la classe ",(0,t.jsx)(r.strong,{children:"User"}),", ou bien impl\xe9menter l'interface ",(0,t.jsx)(r.strong,{children:"UserDetails"})," (qui \xe9tend \xe9galement la classe ",(0,t.jsx)(r.strong,{children:"User"}),")."]}),"\n",(0,t.jsxs)(r.p,{children:["Enfin, l'interface ",(0,t.jsx)(r.strong,{children:"PasswordEncoder"})," est propos\xe9e par Spring Security pour encoder et comparer les mots de passe. Elle offre \xe9galement deux impl\xe9mentations, ",(0,t.jsx)(r.strong,{children:"StandardPasswordEncoder"})," et ",(0,t.jsx)(r.strong,{children:"BCryptPasswordEncoder"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["Spring Security recommande l'utilisation de ",(0,t.jsx)(r.strong,{children:"BCryptPasswordEncoder"}),", comme indiqu\xe9 dans la documentation officielle."]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{src:n(7278).Z+"",width:"683",height:"132"})}),"\n",(0,t.jsx)(r.p,{children:"Avant de passer \xe0 l'impl\xe9mentation, je pr\xe9f\xe8re que nous jetions un coup d'\u0153il sur le m\xe9canisme d'authentification et d'autorisation dans Spring Security."}),"\n",(0,t.jsx)(r.h2,{id:"comprendre-le-m\xe9canisme-de-lauthentification-et-lautorisation",children:"Comprendre le m\xe9canisme de l'authentification et l'autorisation"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{src:n(9664).Z+"",width:"1151",height:"749"})}),"\n",(0,t.jsx)(r.p,{children:"En se basant sur le digramme ci-dessus on peut en conclure deux sc\xe9narios :"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"Lorsque l'on souhaite authentifier un utilisateur par le couple/usrename et lui envoyer les donn\xe9es de sa session sous forme d'un JWT"}),"\n",(0,t.jsx)(r.li,{children:"Lorsqu'un utilisateur tente d'acc\xe9der \xe0 une ressource prot\xe9g\xe9e qui peut n\xe9cessite ou non des autorisations sp\xe9cifiques"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"authentification-dun-utilisateur",children:"Authentification d'un utilisateur"}),"\n",(0,t.jsx)(r.p,{children:"Lorsqu'un utilisateur soumet une requ\xeate HTTP d'authentification, elle traverse la cha\xeene de filtres jusqu'\xe0 atteindre le contr\xf4leur charg\xe9 de l'authentification. Ensuite, le contr\xf4leur demande au service d'authentification de v\xe9rifier les informations fournies par l'utilisateur."}),"\n",(0,t.jsx)(r.p,{children:"Voici les \xe9tapes simplifi\xe9es d'authentification d'un utilisateur dans Spring Security avec JWT :"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"L'utilisateur soumet ses informations d'identification (nom d'utilisateur et mot de passe) via un formulaire de connexion ou une requ\xeate API."}),"\n",(0,t.jsxs)(r.li,{children:["Le filtre ",(0,t.jsx)(r.strong,{children:"JwtAuthenticationFilter"})," intercepte la demande d'authentification."]}),"\n",(0,t.jsxs)(r.li,{children:["Dans ",(0,t.jsx)(r.strong,{children:"JwtAuthenticationFilter"}),", l'authentification de l'utilisateur est effectu\xe9e en v\xe9rifiant les informations d'identification fournies."]}),"\n",(0,t.jsxs)(r.li,{children:["Si l'authentification r\xe9ussit, un objet ",(0,t.jsx)(r.strong,{children:"UsernamePasswordAuthenticationToken"})," est cr\xe9\xe9 pour repr\xe9senter l'identit\xe9 de l'utilisateur authentifi\xe9."]}),"\n",(0,t.jsx)(r.li,{children:"Le contr\xf4leur re\xe7oit la demande d'authentification r\xe9ussie et utilise un service appropri\xe9 pour g\xe9n\xe9rer une r\xe9ponse \xe0 l'utilisateur"}),"\n",(0,t.jsx)(r.li,{children:"Le service cr\xe9e un jeton d'acc\xe8s JWT en incluant les informations n\xe9cessaires (par exemple, le nom d'utilisateur, les autorisations, la dur\xe9e de validit\xe9) et en le signant avec une cl\xe9 secr\xe8te."}),"\n",(0,t.jsx)(r.li,{children:"La r\xe9ponse contenant le jeton d'acc\xe8s JWT est renvoy\xe9e \xe0 l'utilisateur."}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Dans ce sc\xe9nario, on pourrait dire que l'authentification se fait enti\xe8rement dans le service d'authentification, car les filtres ne sont pas directement impliqu\xe9s dans le processus."}),"\n",(0,t.jsx)(r.h3,{id:"demander-une-ressource-n\xe9cessitant-lauthentification",children:"Demander une ressource n\xe9cessitant l'authentification"}),"\n",(0,t.jsx)(r.p,{children:"Pour acc\xe9der \xe0 une ressource prot\xe9g\xe9e dans notre syst\xe8me d'authentification Stateless, il est n\xe9cessaire de fournir un JWT valide qui atteste les autorisations requises."}),"\n",(0,t.jsxs)(r.p,{children:["La requ\xeate va \xeatre intercept\xe9 par le filtre ",(0,t.jsx)(r.code,{children:"JwtAuthenticationFilter"})," qui va exporter le JWT"]}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"Un utilisateur envoie une requ\xeate HTTP pour acc\xe9der \xe0 une ressource prot\xe9g\xe9e dans notre application."}),"\n",(0,t.jsxs)(r.li,{children:["La requ\xeate est intercept\xe9e par le ",(0,t.jsx)(r.code,{children:"JwtAuthenticationFilter"}),", qui v\xe9rifie la pr\xe9sence d'un JWT dans l'en-t\xeate ",(0,t.jsx)(r.code,{children:"Authorization"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:["Si le JWT est pr\xe9sent, le ",(0,t.jsx)(r.code,{children:"JwtAuthenticationFilter"})," extrait et valide le JWT en utilisant une cl\xe9 secr\xe8te ou publique."]}),"\n",(0,t.jsxs)(r.li,{children:["Si le JWT est valide, le ",(0,t.jsx)(r.code,{children:"JwtAuthenticationFilter"})," extrait les informations d'identification (comme le username) du JWT."]}),"\n",(0,t.jsx)(r.li,{children:"On r\xe9cup\xe8re ensuite les d\xe9tails de l'utilisateur en utilisant son username depuis la BDD."}),"\n",(0,t.jsx)(r.li,{children:"Si l'utilisateur n'existe pas ou si d'autres crit\xe8res de validation suppl\xe9mentaires li\xe9s aux besoins sp\xe9cifiques de l'application ne sont pas satisfaits, une exception peut \xeatre lev\xe9e."}),"\n",(0,t.jsxs)(r.li,{children:["Si l'authentification est r\xe9ussie, Le ",(0,t.jsx)(r.code,{children:"JwtAuthenticationFilter"})," cr\xe9e ensuite un objet ",(0,t.jsx)(r.code,{children:"UsernamePasswordAuthenticationToken"})," contenant les informations d'identification de l'utilisateur."]}),"\n",(0,t.jsxs)(r.li,{children:["L'objet ",(0,t.jsx)(r.code,{children:"UsernamePasswordAuthenticationToken"})," est stock\xe9 dans le SecurityContext, g\xe9r\xe9 par le ",(0,t.jsx)(r.code,{children:"SecurityContextHolder"}),"."]}),"\n",(0,t.jsx)(r.li,{children:"La requ\xeate continue son chemin et traverse la cha\xeene de filtres jusqu'\xe0 ce qu'elle atteigne le contr\xf4leur"}),"\n",(0,t.jsx)(r.li,{children:"Si l'authentification \xe9choue \xe0 l'une des \xe9tapes, une exception est lev\xe9e."}),"\n"]}),"\n",(0,t.jsx)(r.h1,{id:"impl\xe9mentation",children:"Impl\xe9mentation"}),"\n",(0,t.jsx)(r.p,{children:"Tout cela est tr\xe8s bien en th\xe9orie, mais rien de mieux que la pratique pour mettre en \u0153uvre tout ce que nous avons vu."}),"\n",(0,t.jsx)(r.p,{children:"L'objectif est de cr\xe9er une API REST Spring boot s\xe9curis\xe9e par Spring security avec JWT (Json Web Token)."}),"\n",(0,t.jsx)(r.h3,{id:"les-endpoints",children:"Les endpoints"}),"\n",(0,t.jsx)(r.p,{children:"Voici les endpoints que notre API doit expos\xe9s :"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"POST /api/v1/auth/register => permet de cr\xe9er un nouveau compte utilisateur"}),"\n",(0,t.jsx)(r.li,{children:"POST /api/v1/auth/authenticate => authentification"}),"\n",(0,t.jsx)(r.li,{children:"POST /api/v1/auth/refresh-token => permet d'actualiser le token"}),"\n",(0,t.jsx)(r.li,{children:"GET /api/v1/admin/resource => permet d'acc\xe8der \xe0 une ressource prot\xe9g\xe9e qui n\xe9cessite le r\xf4le admin et le droit de lecture"}),"\n",(0,t.jsx)(r.li,{children:"DELETE /api/v1/admin/resource => permet d'acc\xe8der \xe0 une ressource prot\xe9g\xe9e qui n\xe9cessite le r\xf4le admin et le droit de suppression"}),"\n",(0,t.jsx)(r.li,{children:"POST /api/v1/user/resource => permet d'acc\xe8der \xe0 une ressource prot\xe9g\xe9e qui n\xe9cessite le r\xf4le user et le droit de cr\xe9ation"}),"\n",(0,t.jsx)(r.li,{children:"PUT /api/v1/user/resource => permet d'acc\xe8der \xe0 une ressource prot\xe9g\xe9e qui n\xe9cessite le r\xf4le user et le droit de modification"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"initialisation-du-projet",children:"Initialisation du projet"}),"\n",(0,t.jsxs)(r.p,{children:["Afin de ne pas alourdir l'article, l'objectif est de se concentrer sur Spring Security. Je vais passer certaines \xe9tapes classiques que chaque d\xe9veloppeur Java devrait savoir faire, comme la cr\xe9ation d'un projet Spring Boot, et je vais sauter \xe9galement les lignes de code qui ne sont pas particuli\xe8rement importantes. Vous pouvez trouver le projet complet sur ",(0,t.jsx)(r.a,{href:"https://github.com/MossaabFrifita/spring-boot-3-security-6-jwt",children:"GitHub"}),", mais je vous recommande vivement de ne pas simplement copier-coller le code. Essayez plut\xf4t de manipuler les choses par vous-m\xeame et n'h\xe9sitez pas \xe0 apporter vos propres modifications pour am\xe9liorer certaines parties ou ajouter de nouvelles fonctionnalit\xe9s."]}),"\n",(0,t.jsx)(r.p,{children:"La premi\xe8re \xe9tape est de cr\xe9er un projet spring boot et ajouter la d\xe9pendance de spring Security, lombok et postgresql ou bien tout autre SGBD de votre choix. Au moment o\xf9 j'\xe9cris cet article on est \xe0 la version 3.1 de Spring boot qui n\xe9cessite au minimum Java 17."}),"\n",(0,t.jsx)(r.p,{children:"Une fois le projet cr\xe9\xe9, importez-le dans votre IDE pr\xe9f\xe9r\xe9 et essayez de le d\xe9marrer. Normalement, vous devriez voir s'afficher par d\xe9faut une page de connexion g\xe9n\xe9r\xe9e automatiquement par Spring Security. Si vous consultez la console, vous verrez que Spring a g\xe9n\xe9r\xe9 un mot de passe par d\xe9faut pour l'utilisateur \"user\" lors du d\xe9marrage de l'application. Notez que vous pouvez personnaliser cette page, mais dans le cas de notre API, nous n'en aurons pas besoin."}),"\n",(0,t.jsx)(r.h3,{id:"cr\xe9ation-des-\xe9num\xe9rations",children:"Cr\xe9ation des \xe9num\xe9rations"}),"\n",(0,t.jsxs)(r.p,{children:['Sous le package "enums", cr\xe9ez l\'\xe9num\xe9ration ',(0,t.jsx)(r.strong,{children:"Privilege"})," qui d\xe9finit explicitement les autorisations qui seront attribu\xe9es \xe0 chaque r\xf4le :"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"package fr.mossaab.security.enums;\r\n\r\npublic enum Privilege {\r\n    READ_PRIVILEGE,\r\n    WRITE_PRIVILEGE,\r\n    DELETE_PRIVILEGE,\r\n    UPDATE_PRIVILEGE;\r\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Cr\xe9ez \xe9galement l'\xe9num\xe9ration ",(0,t.jsx)(r.strong,{children:"Role"})," :"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.enums;\r\n\r\nimport lombok.Getter;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\r\n\r\nimport java.util.List;\r\nimport java.util.Set;\r\nimport java.util.stream.Collectors;\r\n\r\nimport static fr.mossaab.security.enums.Privilege.*;\r\n\r\n@RequiredArgsConstructor\r\npublic enum Role {\r\n    ADMIN(\r\n            Set.of(READ_PRIVILEGE,WRITE_PRIVILEGE,UPDATE_PRIVILEGE,DELETE_PRIVILEGE)\r\n    ),\r\n    USER(\r\n            Set.of(READ_PRIVILEGE)\r\n    );\r\n\r\n    @Getter\r\n    private final Set<Privilege> privileges;\r\n\r\n    public List<SimpleGrantedAuthority> getAuthorities(){\r\n        List<SimpleGrantedAuthority> authorities = getPrivileges()\r\n                .stream()\r\n                .map(privilege -> new SimpleGrantedAuthority(privilege.name()))\r\n                .collect(Collectors.toList());\r\n        authorities.add(new SimpleGrantedAuthority("ROLE_"+this.name()));\r\n        return authorities;\r\n    }\r\n}\r\n\n'})}),"\n",(0,t.jsx)(r.p,{children:"Pour chaque r\xf4le, on d\xe9finit un ensemble de privil\xe8ges dans le constructeur, ce qui permet d'initialiser le r\xf4le avec ses autorisations."}),"\n",(0,t.jsxs)(r.p,{children:["La m\xe9thode ",(0,t.jsx)(r.code,{children:"getAuthorities()"})," retourne une liste d'objets ",(0,t.jsx)(r.code,{children:"SimpleGrantedAuthority"})," obtenue en transformant la (Set) de privil\xe8ges."]}),"\n",(0,t.jsxs)(r.p,{children:["Pour que Spring Security puisse effectuer des v\xe9rifications de r\xf4les et d'autorisations, il faut lui fournir une liste de ",(0,t.jsx)(r.code,{children:"SimpleGrantedAuthority"})]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"SimpleGrantedAuthority"})," est une impl\xe9mentation couramment utilis\xe9e de l'interface ",(0,t.jsx)(r.code,{children:"GrantedAuthority"}),". Les objets ",(0,t.jsx)(r.code,{children:"SimpleGrantedAuthority"})," sont utilis\xe9s pour encapsuler le nom d'une autorit\xe9 ou d'un r\xf4le dans le syst\xe8me."]}),"\n",(0,t.jsx)(r.p,{children:'Le pr\xe9fixe "ROLE" est une convention utilis\xe9e par Spring Security pour diff\xe9rencier les r\xf4les des autres types d\'autorit\xe9s.'}),"\n",(0,t.jsxs)(r.p,{children:["En r\xe9sum\xe9, une ",(0,t.jsx)(r.strong,{children:"Authority"}),"  n'est qu'une simple chaine de caract\xe8res encapsul\xe9e dans  ",(0,t.jsx)(r.strong,{children:"SimpleGrantedAuthority"}),". un R\xf4le n\u2019est ni plus ni moins qu\u2019une ",(0,t.jsx)(r.strong,{children:"Authority"})," pr\xe9c\xe9d\xe9e du pr\xe9fixe \u201cROLE_\u201d"]}),"\n",(0,t.jsxs)(r.p,{children:["Cr\xe9ez aussi l'\xe9num\xe9ration ",(0,t.jsx)(r.strong,{children:"TokenType"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"package fr.mossaab.security.enums;\r\n\r\npublic enum TokenType {\r\n    BEARER\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Le type d'authentification Bearer est utilis\xe9 dans les protocoles bas\xe9s sur les tokens tels que JWT et OAuth 2.0. Lorsque on utilise l'authentification Bearer, le client inclut le token d'acc\xe8s dans l'en-t\xeate de la requ\xeate HTTP(Headers) , g\xe9n\xe9ralement dans l'en-t\xeate d'autorisation, avec le pr\xe9fixe \"Bearer \". Par exemple : \"Authorization: Bearer token\"."}),"\n",(0,t.jsx)(r.h3,{id:"cr\xe9ation-de-lentit\xe9-user",children:"Cr\xe9ation de l'entit\xe9 User"}),"\n",(0,t.jsxs)(r.p,{children:["Cr\xe9ez la classe User qui impl\xe9mente ",(0,t.jsx)(r.code,{children:"UserDetails"})," sous le package entities"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.entities;\r\n\r\nimport fr.mossaab.security.enums.Role;\r\nimport jakarta.persistence.*;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Builder;\r\nimport lombok.Data;\r\nimport lombok.NoArgsConstructor;\r\nimport org.springframework.security.core.GrantedAuthority;\r\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport java.util.Collection;\r\n\r\n@Builder\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\n@Data\r\n@Entity\r\n@Table(name = "_user")\r\npublic class User implements UserDetails {\r\n\r\n    @Id\r\n    @GeneratedValue\r\n    private Long id;\r\n    private String firstname;\r\n    private String lastname;\r\n    private String email;\r\n    private String password;\r\n\r\n    @Enumerated(EnumType.STRING)\r\n    private Role role;\r\n\r\n    @Override\r\n    public Collection<? extends GrantedAuthority> getAuthorities() {\r\n        return role.getAuthorities();\r\n    }\r\n\r\n    @Override\r\n    public String getPassword() {\r\n        return password;\r\n    }\r\n\r\n    @Override\r\n    public String getUsername() {\r\n        return email;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAccountNonExpired() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAccountNonLocked() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isCredentialsNonExpired() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isEnabled() {\r\n        return true;\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:"La classe User est utilis\xe9e pour repr\xe9senter un utilisateur dans Spring Security. Elle fournit les informations n\xe9cessaires pour l'authentification et l'autorisation, ainsi que les autorit\xe9s associ\xe9es \xe0 l'utilisateur."}),"\n",(0,t.jsx)(r.h3,{id:"cr\xe9ation-de-lentit\xe9-refreshtoken",children:"Cr\xe9ation de l'entit\xe9 RefreshToken"}),"\n",(0,t.jsx)(r.p,{children:"Comme mentionn\xe9 pr\xe9c\xe9demment dans cet article, en enregistrant les Refresh Tokens dans la base de donn\xe9es, il devient plus facile de g\xe9rer leur \xe9tat, notamment pour les r\xe9voquer si n\xe9cessaire. Par exemple, si un utilisateur perd son appareil ou souhaite se d\xe9connecter de mani\xe8re proactive, le Refresh Token peut \xeatre marqu\xe9 comme r\xe9voqu\xe9 dans la base de donn\xe9es, emp\xeachant ainsi son utilisation future. On peut aussi contr\xf4ler le nombre de sessions ouvertes par l'utilisateur."}),"\n",(0,t.jsx)(r.p,{children:"Voici la classe RefreshToken"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.entities;\r\n\r\nimport fr.mossaab.security.enums.TokenType;\r\nimport jakarta.persistence.*;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Builder;\r\nimport lombok.Data;\r\nimport lombok.NoArgsConstructor;\r\n\r\nimport java.time.Instant;\r\n\r\n@Data\r\n@Builder\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\n@Entity\r\npublic class RefreshToken {\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.AUTO)\r\n    private long id;\r\n\r\n    @ManyToOne\r\n    @JoinColumn(name = "user_id", referencedColumnName = "id")\r\n    private User user;\r\n\r\n    @Column(nullable = false, unique = true)\r\n    private String token;\r\n\r\n    @Column(nullable = false)\r\n    private Instant expiryDate;\r\n\r\n    public boolean revoked;\n'})}),"\n",(0,t.jsx)(r.h3,{id:"cr\xe9ation-des-repositories-user-et-refreshtoken",children:"Cr\xe9ation des Repositories User et RefreshToken"}),"\n",(0,t.jsx)(r.p,{children:"Maintenant, nos entit\xe9s n\xe9cessitent un Repository pour la persistance et l'acc\xe8s aux donn\xe9es en base de donn\xe9es. Cr\xe9ez-les dans le package repository."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"package fr.mossaab.security.repository;\r\n\r\nimport fr.mossaab.security.entities.User;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport java.util.Optional;\r\n\r\npublic interface UserRepository extends JpaRepository<User, Long> {\r\n    Optional<User> findByEmail(String email);\r\n}\r\n\n"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Java",children:"package fr.mossaab.security.repository;\r\n\r\nimport fr.mossaab.security.entities.RefreshToken;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport java.util.Optional;\r\n\r\npublic interface RefreshTokenRepository extends JpaRepository<RefreshToken, Long> {\r\n\r\n    Optional<RefreshToken> findByToken(String token);\r\n\r\n}\r\n\n"})}),"\n",(0,t.jsx)(r.h3,{id:"d\xe9finition-des-payloads",children:"D\xe9finition des payloads"}),"\n",(0,t.jsx)(r.p,{children:"Notre API a besoin de d\xe9finir les payloads pour les requ\xeates et les r\xe9ponses."}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"Les requ\xeates :"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"AuthenticationRequest"})," : permet d'encapsuler les donn\xe9es de la requ\xeate d'authentification"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"package fr.mossaab.security.payload.request;\r\n\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Builder;\r\nimport lombok.Data;\r\nimport lombok.NoArgsConstructor;\r\n\r\n@Data\r\n@Builder\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\npublic class AuthenticationRequest {\r\n    private String email;\r\n    private String password;\r\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"RefreshTokenRequest"})," : permet d'encapsuler les donn\xe9es de la requ\xeate de rafra\xeechissement du token."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"package fr.mossaab.security.payload.request;\r\n\r\nimport lombok.Data;\r\n\r\n@Data\r\npublic class RefreshTokenRequest {\r\n    private String refreshToken;\r\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"RegisterRequest"}),": permet d'encapsuler les donn\xe9es de la requ\xeate d'inscription"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.payload.request;\r\n\r\nimport fr.mossaab.security.enums.Role;\r\nimport fr.mossaab.security.validation.StrongPassword;\r\nimport jakarta.validation.constraints.Email;\r\nimport jakarta.validation.constraints.NotBlank;\r\nimport jakarta.validation.constraints.NotNull;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Builder;\r\nimport lombok.Data;\r\nimport lombok.NoArgsConstructor;\r\n\r\n@Data\r\n@Builder\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\npublic class RegisterRequest {\r\n\r\n    @NotBlank(message = "firstname is required")\r\n    private String firstname;\r\n    @NotBlank(message = "lastname is required")\r\n    private String lastname;\r\n    @NotBlank(message = "email is required")\r\n    @Email(message = "email format is not valid")\r\n    private String email;\r\n    @NotBlank(message = "password is required")\r\n    @StrongPassword\r\n    private String password;\r\n    @NotNull\r\n    private Role role;\r\n}\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"Les r\xe9ponses :"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"AuthenticationResponse"})," : permet d'encapsuler les donn\xe9es de la r\xe9ponse d'authentification"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.payload.response;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Builder;\r\nimport lombok.Data;\r\nimport lombok.NoArgsConstructor;\r\nimport java.util.List;\r\n\r\n@Data\r\n@Builder\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\npublic class AuthenticationResponse {\r\n    private  Long id;\r\n    private String email;\r\n    private List<String> roles;\r\n\r\n    @JsonProperty("access_token")\r\n    private String accessToken;\r\n    @JsonProperty("refresh_token")\r\n    private String refreshToken;\r\n    @JsonProperty("token_type")\r\n    private String tokenType;\r\n\r\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"RefreshTokenResponse"}),":  permet d'encapsuler les donn\xe9es de la r\xe9ponse de rafra\xeechissement du token."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.payload.response;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport fr.mossaab.security.enums.TokenType;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Builder;\r\nimport lombok.Data;\r\nimport lombok.NoArgsConstructor;\r\n\r\n@Data\r\n@Builder\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\npublic class RefreshTokenResponse {\r\n\r\n    @JsonProperty("access_token")\r\n    private String accessToken;\r\n    @JsonProperty("refresh_token")\r\n    private String refreshToken;\r\n    @JsonProperty("token_type")\r\n    private String tokenType = TokenType.BEARER.name();\r\n\r\n}\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"impl\xe9mentation-du-service-jwtservice",children:"Impl\xe9mentation du Service JwtService"}),"\n",(0,t.jsxs)(r.p,{children:["Le ",(0,t.jsx)(r.code,{children:"JwtService"})," est une interface qui d\xe9finit des m\xe9thodes permettant de g\xe9n\xe9rer, extraire et valider les JWT. Cette interface joue un r\xf4le essentiel dans la gestion des JWT et fournit des fonctionnalit\xe9s importantes pour les manipuler."]}),"\n",(0,t.jsx)(r.p,{children:"Les m\xe9thodes principales de cette classe sont :"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"extractUserName(String token)"})," : Cette m\xe9thode extrait le nom d'utilisateur \xe0 partir du JWT."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"generateToken(UserDetails userDetails)"})," : Cette m\xe9thode g\xe9n\xe8re un nouveau JWT \xe0 partir des informations de l'utilisateur fourni."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"isTokenValid(String token, UserDetails userDetails)"})," : Cette m\xe9thode v\xe9rifie si un JWT est valide en comparant le nom d'utilisateur extrait du JWT avec le nom d'utilisateur fourni par ",(0,t.jsx)(r.code,{children:"UserDetails"}),". Elle v\xe9rifie \xe9galement si le JWT a expir\xe9."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["On a besoin de la biblioth\xe8que ",(0,t.jsx)(r.code,{children:"io.jsonwebtoken"})," pour g\xe9n\xe9rer et valider les JWT. Ajoutez les d\xe9pendances suivantes dans vote pom.xml :"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-xml",children:"\x3c!-- ===== jjwt ===== --\x3e\r\n<dependency>\r\n    <groupId>io.jsonwebtoken</groupId>\r\n    <artifactId>jjwt-api</artifactId>\r\n    <version>0.11.5</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>io.jsonwebtoken</groupId>\r\n    <artifactId>jjwt-impl</artifactId>\r\n    <version>0.11.5</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>io.jsonwebtoken</groupId>\r\n    <artifactId>jjwt-jackson</artifactId>\r\n    <version>0.11.5</version>\r\n</dependency>\n"})}),"\n",(0,t.jsx)(r.p,{children:"Elle utilise \xe9galement des propri\xe9t\xe9s configur\xe9es dans le fichier de configuration (application.yml), telles que la cl\xe9 secr\xe8te et les dur\xe9es d'expiration des JWT."}),"\n",(0,t.jsxs)(r.p,{children:["Cr\xe9ez l'impl\xe9mentation ",(0,t.jsx)(r.code,{children:"JwtServiceImpl"})," du service ",(0,t.jsx)(r.code,{children:"JwtService"})," :"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.service.impl;\r\n\r\nimport fr.mossaab.security.service.JwtService;\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jwts;\r\nimport io.jsonwebtoken.SignatureAlgorithm;\r\nimport io.jsonwebtoken.io.Decoders;\r\nimport io.jsonwebtoken.security.Keys;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.security.Key;\r\nimport java.util.Date;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.function.Function;\r\n\r\n@Service\r\npublic class JwtServiceImpl implements JwtService {\r\n\r\n    @Value("${application.security.jwt.secret-key}")\r\n    private String secretKey;\r\n\r\n    @Value("${application.security.jwt.expiration}")\r\n    private long jwtExpiration;\r\n    @Value("${application.security.jwt.refresh-token.expiration}")\r\n    private long refreshExpiration;\r\n\r\n    @Override\r\n    public String extractUserName(String token) {\r\n        return extractClaim(token, Claims::getSubject);\r\n    }\r\n\r\n    @Override\r\n    public String generateToken(UserDetails userDetails) {\r\n        return generateToken(new HashMap<>(), userDetails);\r\n    }\r\n\r\n    @Override\r\n    public boolean isTokenValid(String token, UserDetails userDetails) {\r\n        final String userName = extractUserName(token);\r\n        return (userName.equals(userDetails.getUsername())) && !isTokenExpired(token);\r\n    }\r\n\r\n    private boolean isTokenExpired(String token) {\r\n        return extractExpiration(token).before(new Date());\r\n    }\r\n    private Date extractExpiration(String token) {\r\n        return extractClaim(token, Claims::getExpiration);\r\n    }\r\n    private String generateToken(Map<String, Object> extraClaims, UserDetails userDetails) {\r\n        return buildToken(extraClaims, userDetails,jwtExpiration);\r\n    }\r\n\r\n    private String buildToken(\r\n            Map<String, Object> extraClaims,\r\n            UserDetails userDetails,\r\n            long expiration\r\n    ) {\r\n        return Jwts\r\n                .builder()\r\n                .setClaims(extraClaims)\r\n                .setSubject(userDetails.getUsername())\r\n                .setIssuedAt(new Date(System.currentTimeMillis()))\r\n                .setExpiration(new Date(System.currentTimeMillis() + expiration))\r\n                .signWith(getSigningKey(), SignatureAlgorithm.HS256)\r\n                .compact();\r\n    }\r\n\r\n    private <T> T extractClaim(String token, Function<Claims, T> claimsResolvers) {\r\n        final Claims claims = extractAllClaims(token);\r\n        return claimsResolvers.apply(claims);\r\n    }\r\n    private Claims extractAllClaims(String token) {\r\n        return Jwts.parserBuilder()\r\n                .setSigningKey(getSigningKey())\r\n                .build()\r\n                .parseClaimsJws(token)\r\n                .getBody();\r\n    }\r\n    private Key getSigningKey() {\r\n        byte[] keyBytes = Decoders.BASE64.decode(secretKey);\r\n        return Keys.hmacShaKeyFor(keyBytes);\r\n    }\r\n}\r\n\n'})}),"\n",(0,t.jsxs)(r.p,{children:["La m\xe9thode ",(0,t.jsx)(r.code,{children:"extractAllClaims"})," est responsable de l'extraction de toutes les claims d'un token. elle permet de valider la signature \xe0 l'aide de la cl\xe9 secr\xe8te, puis renvoyer tous Claims ou lever une exception si le token n'est pas valide. Voici les exceptions qui peuvent \xeatre lev\xe9es :"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"ExpiredJwtException"})," : Cette exception est lev\xe9e lorsque le token JWT est expir\xe9 et n'est plus valide."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"UnsupportedJwtException"})," : Cette exception est lev\xe9e lorsque le token JWT est malform\xe9 ou utilise un algorithme de signature non pris en charge."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"MalformedJwtException"})," : Cette exception est lev\xe9e lorsque le token JWT est mal form\xe9 ou invalide."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"SignatureException"})," : Cette exception est lev\xe9e lorsque la signature du token JWT ne peut pas \xeatre v\xe9rifi\xe9e."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"IllegalArgumentException"})," : Cette exception est lev\xe9e lorsqu'un argument invalide est pass\xe9 \xe0 une m\xe9thode."]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"impl\xe9mentation-du-service-authenticationservice",children:"Impl\xe9mentation du Service AuthenticationService"}),"\n",(0,t.jsxs)(r.p,{children:["L'interface ",(0,t.jsx)(r.code,{children:"AuthenticationService"})," fournit des m\xe9thodes pour l'enregistrement d'un nouveau utilisateur (",(0,t.jsx)(r.code,{children:"register"}),") et l'authentification d'un utilisateur (",(0,t.jsx)(r.code,{children:"authenticate"}),")."]}),"\n",(0,t.jsxs)(r.p,{children:["Cr\xe9ez ",(0,t.jsx)(r.code,{children:"AuthenticationServiceImpl"})," qui est une classe qui impl\xe9mente l'interface ",(0,t.jsx)(r.code,{children:"AuthenticationService"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.service.impl;\r\n\r\nimport fr.mossaab.security.enums.TokenType;\r\nimport fr.mossaab.security.payload.request.AuthenticationRequest;\r\nimport fr.mossaab.security.payload.request.RegisterRequest;\r\nimport fr.mossaab.security.payload.response.AuthenticationResponse;\r\nimport fr.mossaab.security.service.AuthenticationService;\r\nimport fr.mossaab.security.service.JwtService;\r\nimport fr.mossaab.security.entities.User;\r\nimport fr.mossaab.security.repository.UserRepository;\r\nimport fr.mossaab.security.service.RefreshTokenService;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.security.authentication.AuthenticationManager;\r\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\r\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\n\r\n\r\n@Service @Transactional\r\n@RequiredArgsConstructor\r\npublic class AuthenticationServiceImpl implements AuthenticationService {\r\n\r\n    private final PasswordEncoder passwordEncoder;\r\n    private final JwtService jwtService;\r\n    private final UserRepository userRepository;\r\n    private final AuthenticationManager authenticationManager;\r\n    private final RefreshTokenService refreshTokenService;\r\n    \r\n    @Override\r\n    public AuthenticationResponse register(RegisterRequest request) {\r\n        var user = User.builder()\r\n                .firstname(request.getFirstname())\r\n                .lastname(request.getLastname())\r\n                .email(request.getEmail())\r\n                .password(passwordEncoder.encode(request.getPassword()))\r\n                .role(request.getRole())\r\n                .build();\r\n        user = userRepository.save(user);\r\n        var jwt = jwtService.generateToken(user);\r\n        var refreshToken = refreshTokenService.createRefreshToken(user.getId());\r\n\r\n        var roles = user.getRole().getAuthorities()\r\n                .stream()\r\n                .map(SimpleGrantedAuthority::getAuthority)\r\n                .toList();\r\n\r\n        return AuthenticationResponse.builder()\r\n                .accessToken(jwt)\r\n                .email(user.getEmail())\r\n                .id(user.getId())\r\n                .refreshToken(refreshToken.getToken())\r\n                .roles(roles)\r\n                .tokenType( TokenType.BEARER.name())\r\n                .build();\r\n    }\r\n\r\n    @Override\r\n    public AuthenticationResponse authenticate(AuthenticationRequest request) {\r\n        authenticationManager.authenticate(\r\n                new UsernamePasswordAuthenticationToken(request.getEmail(),request.getPassword()));\r\n\r\n        var user = userRepository.findByEmail(request.getEmail()).orElseThrow(() -> new IllegalArgumentException("Invalid email \t\tor password."));\r\n        var jwt = jwtService.generateToken(user);\r\n        var refreshToken = refreshTokenService.createRefreshToken(user.getId());\r\n        return AuthenticationResponse.builder()\r\n                .accessToken(jwt)\r\n                .email(user.getEmail())\r\n                .id(user.getId())\r\n                .refreshToken(refreshToken.getToken())\r\n                .tokenType( TokenType.BEARER.name())\r\n                .build();\r\n    }\r\n}\r\n\n'})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"AuthenticationServiceImpl"})," a besoin d'un :"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"PasswordEncoder"})," pour encoder le mot de passe de l'utilisateur lors de l'enregistrement."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"JwtService"})," qu'on a d\xe9j\xe0 fourni une impl\xe9mentation pour g\xe9n\xe9rer le JWT lors de l'enregistrement et le valider lors de l'authentification."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"UserRepository"})," pour acc\xe9der aux donn\xe9es des utilisateurs en base de donn\xe9es."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"l'AuthenticationManager"})," pour effectuer l'authentification de l'utilisateur lors de l'appel \xe0 la m\xe9thode ",(0,t.jsx)(r.code,{children:"authenticate"})," qui re\xe7oit un ",(0,t.jsx)(r.code,{children:"UsernamePasswordAuthenticationToken"})," comme on l'a vu dans la partie th\xe9orique."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"RefreshTokenService"})," pour cr\xe9er un token de rafra\xeechissement lors de l'enregistrement et de l'authentification."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Dans la m\xe9thode ",(0,t.jsx)(r.code,{children:"register"}),", on cr\xe9e un nouvel utilisateur en utilisant les informations fournies dans la demande (",(0,t.jsx)(r.code,{children:"RegisterRequest"}),"), puis on le sauvegarde en base de donn\xe9es. Ensuite, on g\xe9n\xe8re un token JWT pour l'utilisateur, on cr\xe9e un token de rafra\xeechissement et on renvoie une r\xe9ponse d'authentification contenant les informations n\xe9cessaires."]}),"\n",(0,t.jsxs)(r.p,{children:["Dans la m\xe9thode ",(0,t.jsx)(r.code,{children:"authenticate"}),", on utilise l'",(0,t.jsx)(r.code,{children:"AuthenticationManager"})," pour valider les informations d'authentification de l'utilisateur (on verra par la suite comment configurer ",(0,t.jsx)(r.code,{children:"l'AuthenticationManager"}),"). Si l'authentification est r\xe9ussie, on r\xe9cup\xe8re l'utilisateur correspondant \xe0 l'adresse e-mail fournie, on g\xe9n\xe8re un token JWT et un token de rafra\xeechissement, puis on renvoie une r\xe9ponse d'authentification avec les informations appropri\xe9es."]}),"\n",(0,t.jsxs)(r.p,{children:["Maintenant l'\xe9tape suivante est de fournir une impl\xe9mentation du service ",(0,t.jsx)(r.code,{children:"RefreshTokenService"})]}),"\n",(0,t.jsx)(r.h3,{id:"impl\xe9mentation-du-service-refreshtokenservice",children:"Impl\xe9mentation du Service RefreshTokenService"}),"\n",(0,t.jsx)(r.p,{children:"RefreshTokenService est responsable de la cr\xe9ation, la v\xe9rification et la r\xe9g\xe9n\xe9ration des tokens de rafra\xeechissement"}),"\n",(0,t.jsx)(r.p,{children:"Il a besoin d'un :"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"UserRepository"})," pour r\xe9cup\xe9rer l'utilisateur par son ID et v\xe9rifier qu'il fait partie de notre syst\xe8me."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"RefreshTokenRepository"})," pour g\xe9rer le RefreshToken en base de donn\xe9es."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"JwtService"})," pour g\xe9n\xe9rer de nouveaux tokens JWT lors de la r\xe9g\xe9n\xe9ration."]}),"\n",(0,t.jsx)(r.li,{children:"Attribut qui r\xe9cup\xe8re la dur\xe9e d'expiration des RefreshTokens  \xe0 partir de la configuration."}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Cr\xe9ez l'impl\xe9mentation  RefreshTokenServiceImpl :"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.service.impl;\r\n\r\nimport fr.mossaab.security.entities.RefreshToken;\r\nimport fr.mossaab.security.entities.User;\r\nimport fr.mossaab.security.enums.TokenType;\r\nimport fr.mossaab.security.exception.TokenException;\r\nimport fr.mossaab.security.payload.request.RefreshTokenRequest;\r\nimport fr.mossaab.security.payload.response.RefreshTokenResponse;\r\nimport fr.mossaab.security.repository.RefreshTokenRepository;\r\nimport fr.mossaab.security.repository.UserRepository;\r\nimport fr.mossaab.security.service.JwtService;\r\nimport fr.mossaab.security.service.RefreshTokenService;\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.time.Instant;\r\nimport java.util.Base64;\r\nimport java.util.Optional;\r\nimport java.util.UUID;\r\n\r\n@Service\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class RefreshTokenServiceImpl implements RefreshTokenService {\r\n\r\n    private final UserRepository userRepository;\r\n    private final RefreshTokenRepository refreshTokenRepository;\r\n    private final JwtService jwtService;\r\n\r\n    @Value("${application.security.jwt.refresh-token.expiration}")\r\n    private long refreshExpiration;\r\n    \r\n    @Override\r\n    public RefreshToken createRefreshToken(Long userId) {\r\n        User user = userRepository.findById(userId).orElseThrow(() -> new RuntimeException("User not found"));\r\n        RefreshToken refreshToken = RefreshToken.builder()\r\n                .revoked(false)\r\n                .user(user)\r\n                .token(Base64.getEncoder().encodeToString(UUID.randomUUID().toString().getBytes()))\r\n                .expiryDate(Instant.now().plusMillis(refreshExpiration))\r\n                .build();\r\n        return refreshTokenRepository.save(refreshToken);\r\n    }\r\n\r\n    @Override\r\n    public RefreshToken verifyExpiration(RefreshToken token) {\r\n        if(token == null){\r\n            log.error("Token is null");\r\n            throw new TokenException(null, "Token is null");\r\n        }\r\n        if(token.getExpiryDate().compareTo(Instant.now()) < 0 ){\r\n            refreshTokenRepository.delete(token);\r\n            throw new TokenException(token.getToken(), "Refresh token was expired. Please make a new authentication request");\r\n        }\r\n        return token;\r\n    }\r\n\r\n    @Override\r\n    public RefreshTokenResponse generateNewToken(RefreshTokenRequest request) {\r\n        User user = refreshTokenRepository.findByToken(request.getRefreshToken())\r\n                .map(this::verifyExpiration)\r\n                .map(RefreshToken::getUser)\r\n                .orElseThrow(() -> new TokenException(request.getRefreshToken(),"Refresh token does not exist"));\r\n\r\n        String token = jwtService.generateToken(user);\r\n        return RefreshTokenResponse.builder()\r\n                .accessToken(token)\r\n                .refreshToken(request.getRefreshToken())\r\n                .tokenType(TokenType.BEARER.name())\r\n                .build();\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["La m\xe9thode ",(0,t.jsx)(r.code,{children:"createRefreshToken"})," est responsable de la cr\xe9ation d'un nouveau RefreshToken pour un utilisateur sp\xe9cifi\xe9 (r\xe9cup\xe9r\xe9 \xe0 par son ID). Elle g\xe9n\xe8re un token unique \xe0 l'aide de ",(0,t.jsx)(r.code,{children:"UUID.randomUUID()"}),", l'encode en Base64, d\xe9finit la date d'expiration en fonction de la dur\xe9e configur\xe9e, puis enregistre le token en base de donn\xe9es."]}),"\n",(0,t.jsxs)(r.p,{children:["La m\xe9thode ",(0,t.jsx)(r.code,{children:"verifyExpiration"})," est utilis\xe9e pour v\xe9rifier si le RefreshToken est expir\xe9. Si le token est nul ou est expir\xe9, une exception de type ",(0,t.jsx)(r.code,{children:"TokenException"})," est lev\xe9e. On verra aussi par la suite comment cette exception et comment la g\xe9rer."]}),"\n",(0,t.jsxs)(r.p,{children:["La m\xe9thode ",(0,t.jsx)(r.code,{children:"generateNewToken"})," est appel\xe9e lorsqu'un utilisateur souhaite g\xe9n\xe9rer un nouveau token en utilisant un RefreshToken existant. Elle r\xe9cup\xe8re le token de la base de donn\xe9es, v\xe9rifie s'il est expir\xe9, r\xe9cup\xe8re l'utilisateur associ\xe9 au token, g\xe9n\xe8re un nouveau token JWT \xe0 l'aide du ",(0,t.jsx)(r.code,{children:"JwtService"}),", puis renvoie la r\xe9ponse."]}),"\n",(0,t.jsx)(r.h3,{id:"gestion-des-exceptions",children:"Gestion des exceptions"}),"\n",(0,t.jsxs)(r.p,{children:["Dans la couche services nous avons utilis\xe9 une exception personnalis\xe9e de type",(0,t.jsx)(r.code,{children:"TokenException"})]}),"\n",(0,t.jsxs)(r.p,{children:["Cr\xe9ez la classe ",(0,t.jsx)(r.code,{children:"TokenException"})," qui \xe9tend ",(0,t.jsx)(r.code,{children:"RuntimeException"})," sous le package ",(0,t.jsx)(r.code,{children:"exception"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.exception;\r\n\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.web.bind.annotation.ResponseStatus;\r\n\r\n@ResponseStatus(HttpStatus.FORBIDDEN)\r\npublic class TokenException extends RuntimeException {\r\n\r\n    public TokenException(String token, String message) {\r\n        super(String.format("Failed for [%s]: %s", token, message));\r\n    }\r\n\r\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["Cr\xe9ez \xe9galement classe ",(0,t.jsx)(r.code,{children:"ErrorResponse"})," qui va encapsuler les informations d'une r\xe9ponse d'erreur qui sera envoy\xe9 \xe0 l'utilisateur"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"package fr.mossaab.security.handlers;\r\n\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Builder;\r\nimport lombok.Data;\r\nimport lombok.NoArgsConstructor;\r\n\r\nimport java.time.Instant;\r\n\r\n@Data\r\n@NoArgsConstructor @AllArgsConstructor\r\n@Builder\r\npublic class ErrorResponse {\r\n    private int status;\r\n    private String error;\r\n    private Instant timestamp;\r\n    private String message;\r\n    private String path;\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Voici une explication des attributs de la classe :"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"status"})," : C'est le code de statut de l'erreur HTTP par exemple (401,403)."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"error"})," : Une cha\xeene de caract\xe8res repr\xe9sentant le type d'erreur."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"timestamp"})," : Le moment o\xf9 l'erreur s'est produite."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"message"})," :  Le message d\xe9taill\xe9 d\xe9crivant l'erreur."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"path"})," : L'URI de la requ\xeate qui a d\xe9clench\xe9 l'erreur."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Ensuite, nous avons besoin d'un Handler qui intercepte les exceptions lev\xe9es et fournit une r\xe9ponse personnalis\xe9e en utilisant notre classe ",(0,t.jsx)(r.code,{children:"ErrorResponse"})," que nous venons de cr\xe9er :"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.handlers;\r\n\r\n\r\nimport fr.mossaab.security.exception.TokenException;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.ExceptionHandler;\r\nimport org.springframework.web.bind.annotation.ResponseStatus;\r\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\r\nimport org.springframework.web.context.request.WebRequest;\r\n\r\nimport java.time.Instant;\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n@RestControllerAdvice\r\npublic class TokenControllerHandler {\r\n\r\n    @ExceptionHandler(value = TokenException.class)\r\n    @ResponseStatus(HttpStatus.FORBIDDEN)\r\n    public ResponseEntity<ErrorResponse> handleRefreshTokenException(TokenException ex, WebRequest request){\r\n       final ErrorResponse errorResponse = ErrorResponse.builder()\r\n                .timestamp(Instant.now())\r\n                .error("Invalid Token")\r\n                .status(HttpStatus.FORBIDDEN.value())\r\n                .message(ex.getMessage())\r\n                .path(request.getDescription(false))\r\n                .build();\r\n        return new ResponseEntity<>(errorResponse,HttpStatus.FORBIDDEN);\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"@RestControllerAdvice"})," est une annotation qui indique \xe0 Spring qu'il s'agit d'un composant global qui intercepte les exceptions lev\xe9es par les contr\xf4leurs et fournit une r\xe9ponse appropri\xe9e."]}),"\n",(0,t.jsxs)(r.p,{children:["La m\xe9thode ",(0,t.jsx)(r.code,{children:"handleRefreshTokenException"})," est annot\xe9e avec ",(0,t.jsx)(r.code,{children:"@ExceptionHandler"})," pour sp\xe9cifier qu'elle doit \xeatre ex\xe9cut\xe9e lorsqu'une exception de type ",(0,t.jsx)(r.code,{children:"TokenException"})," est lev\xe9e."]}),"\n",(0,t.jsxs)(r.p,{children:["Lorsqu'une ",(0,t.jsx)(r.code,{children:"TokenException"})," est lev\xe9e, cette m\xe9thode est appel\xe9e pour la g\xe9rer. Elle re\xe7oit l'exception (",(0,t.jsx)(r.code,{children:"ex"}),") et l'objet ",(0,t.jsx)(r.code,{children:"WebRequest"})," associ\xe9 \xe0 la requ\xeate en cours."]}),"\n",(0,t.jsxs)(r.p,{children:["La m\xe9thode cr\xe9e une instance d'",(0,t.jsx)(r.code,{children:"ErrorResponse"})," avec les d\xe9tails de l'erreur, ensuite, elle retourne une ",(0,t.jsx)(r.code,{children:"ResponseEntity"})," contenant l'objet ",(0,t.jsx)(r.code,{children:"ErrorResponse"})," et le code de statut HTTP correspondant (ici, ",(0,t.jsx)(r.code,{children:"HttpStatus.FORBIDDEN"}),")."]}),"\n",(0,t.jsx)(r.h3,{id:"cr\xe9ation-des-contr\xf4leurs-rest",children:"Cr\xe9ation des contr\xf4leurs Rest"}),"\n",(0,t.jsx)(r.p,{children:"Maintenant que notre couche service est d\xe9velopp\xe9e, il est temps de cr\xe9er les contr\xf4leurs. Pour notre API, nous avons besoin d'un contr\xf4leur qui sera responsable de l'authentification et d'un autre qui simule l'acc\xe8s \xe0 des ressources prot\xe9g\xe9es."}),"\n",(0,t.jsxs)(r.p,{children:["Cr\xe9ez alors ",(0,t.jsx)(r.code,{children:"AuthenticationController"})," qui contient trois m\xe9thodes : ",(0,t.jsx)(r.code,{children:"register"})," qui g\xe8re la requ\xeate d'inscription, ",(0,t.jsx)(r.code,{children:"authenticate"}),"  qui g\xe8re la requ\xeate d'authentification et ",(0,t.jsx)(r.code,{children:"refreshToken"})," pour actualiser le JWT"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.controller;\r\n\r\nimport fr.mossaab.security.payload.request.AuthenticationRequest;\r\nimport fr.mossaab.security.payload.request.RefreshTokenRequest;\r\nimport fr.mossaab.security.payload.request.RegisterRequest;\r\nimport fr.mossaab.security.payload.response.AuthenticationResponse;\r\nimport fr.mossaab.security.payload.response.RefreshTokenResponse;\r\nimport fr.mossaab.security.service.AuthenticationService;\r\nimport fr.mossaab.security.service.RefreshTokenService;\r\nimport jakarta.validation.Valid;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\n\r\n\r\n@RestController\r\n@RequestMapping("/api/v1/auth")\r\n@RequiredArgsConstructor\r\npublic class AuthenticationController {\r\n\r\n    private final AuthenticationService authenticationService;\r\n    private final RefreshTokenService refreshTokenService;\r\n\r\n\r\n    @PostMapping("/register")\r\n    public ResponseEntity<AuthenticationResponse> register(@Valid @RequestBody RegisterRequest request) {\r\n        return ResponseEntity.ok(authenticationService.register(request));\r\n    }\r\n\r\n    @PostMapping("/authenticate")\r\n    public ResponseEntity<AuthenticationResponse> authenticate(@RequestBody AuthenticationRequest request) {\r\n        return ResponseEntity.ok(authenticationService.authenticate(request));\r\n    }\r\n    @PostMapping("/refresh-token")\r\n    public ResponseEntity<RefreshTokenResponse> refreshToken(@RequestBody RefreshTokenRequest request) {\r\n        return ResponseEntity.ok(refreshTokenService.generateNewToken(request));\r\n    }\r\n\r\n\r\n\r\n}\r\n\n'})}),"\n",(0,t.jsxs)(r.p,{children:["L'annotation ",(0,t.jsx)(r.code,{children:"@Valid"})," indique \xe0 Spring que ",(0,t.jsx)(r.code,{children:"RegisterRequest"})," doit \xeatre valid\xe9. Je ne vais pas entrer dans les d\xe9tails de la validation des beans, car ce n'est pas le sujet de cet article."]}),"\n",(0,t.jsxs)(r.p,{children:["Ce contr\xf4leur est annot\xe9 avec ",(0,t.jsx)(r.code,{children:"@RestController"})," pour indiquer qu'il est responsable de la gestion des requ\xeates REST, et les diff\xe9rentes m\xe9thodes sont annot\xe9es avec ",(0,t.jsx)(r.code,{children:"@PostMapping"})," pour sp\xe9cifier le type de requ\xeate HTTP qu'elles traitent."]}),"\n",(0,t.jsxs)(r.p,{children:["Cr\xe9ez ",(0,t.jsx)(r.code,{children:"AuthorizationController"})," qui va simuler l'acc\xe8s aux ressources prot\xe9g\xe9es"]}),"\n",(0,t.jsx)(r.p,{children:"Le but est de simuler l'acc\xe8s aux endpoints prot\xe9g\xe9s qui n\xe9cessitent des autorisations sp\xe9cifiques. Comme vous vous en souvenez, nous avons d\xe9fini les endpoints suivants :"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"GET /api/v1/admin/resource => permet d'acc\xe8der \xe0 une ressource prot\xe9g\xe9e qui n\xe9cessite le r\xf4le admin et le droit de lecture"}),"\n",(0,t.jsx)(r.li,{children:"DELETE /api/v1/admin/resource => permet d'acc\xe8der \xe0 une ressource prot\xe9g\xe9e qui n\xe9cessite le r\xf4le admin et le droit de suppression"}),"\n",(0,t.jsx)(r.li,{children:"POST /api/v1/user/resource => permet d'acc\xe8der \xe0 une ressource prot\xe9g\xe9e qui n\xe9cessite le r\xf4le user et le droit de cr\xe9ation"}),"\n",(0,t.jsx)(r.li,{children:"PUT /api/v1/user/resource => permet d'acc\xe8der \xe0 une ressource prot\xe9g\xe9e qui n\xe9cessite le r\xf4le user et le droit de modification"}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Nous allons cr\xe9er 4 m\xe9thodes dans ",(0,t.jsx)(r.code,{children:"AuthorizationController"}),"  pour les exposer :"]}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"sayHelloWithRoleAdminAndReadAuthority()"}),": Cette m\xe9thode ",(0,t.jsx)(r.code,{children:"GET"})," n\xe9cessite le r\xf4le ",(0,t.jsx)(r.code,{children:"ADMIN"})," et l'autorit\xe9 de lecture (",(0,t.jsx)(r.code,{children:"READ_PRIVILEGE"}),") pour y acc\xe9der."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"sayHelloWithRoleAdminAndDeleteAuthority()"}),": Cette m\xe9thode ",(0,t.jsx)(r.code,{children:"DELETE"})," n\xe9cessite le r\xf4le ",(0,t.jsx)(r.code,{children:"ADMIN"})," et l'autorit\xe9 de suppression (",(0,t.jsx)(r.code,{children:"DELETE_PRIVILEGE"}),") pour y acc\xe9der."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"sayHelloWithRoleUserAndCreateAuthority()"}),": Cette m\xe9thode ",(0,t.jsx)(r.code,{children:"POST"})," n\xe9cessite le r\xf4le ",(0,t.jsx)(r.code,{children:"USER"})," et l'autorit\xe9 de cr\xe9ation (",(0,t.jsx)(r.code,{children:"CREATE_PRIVILEGE"}),") pour y acc\xe9der. Elle renvoie une r\xe9ponse indiquant que l'utilisateur a acc\xe8s \xe0 une ressource prot\xe9g\xe9e n\xe9cessitant le r\xf4le utilisateur et l'autorit\xe9 de cr\xe9ation."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"sayHelloWithRoleUserAndUpdateAuthority()"}),": Cette m\xe9thode ",(0,t.jsx)(r.code,{children:"PUT"})," n\xe9cessite le r\xf4le ",(0,t.jsx)(r.code,{children:"USER"})," et l'autorit\xe9 de mise \xe0 jour (",(0,t.jsx)(r.code,{children:"UPDATE_PRIVILEGE"}),") pour y acc\xe9der."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Chaque m\xe9thode renvoie simplement un message de succ\xe8s."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.controller;\r\n\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.security.access.prepost.PreAuthorize;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\n\r\n@RestController\r\n@RequestMapping("/api/v1")\r\n@PreAuthorize("hasAnyRole(\'ADMIN\',\'USER\')")\r\npublic class AuthorizationController {\r\n\r\n\r\n\r\n    @GetMapping("/admin/resource")\r\n    @PreAuthorize("hasAuthority(\'READ_PRIVILEGE\') and hasRole(\'ADMIN\')")\r\n    public ResponseEntity<String> sayHelloWithRoleAdminAndReadAuthority() {\r\n        return ResponseEntity.ok("Hello, you have access to a protected resource that requires admin role and read authority.");\r\n    }\r\n\r\n    @DeleteMapping("/admin/resource")\r\n    @PreAuthorize("hasAuthority(\'DELETE_PRIVILEGE\') and hasRole(\'ADMIN\')")\r\n    public ResponseEntity<String> sayHelloWithRoleAdminAndDeleteAuthority() {\r\n        return ResponseEntity.ok("Hello, you have access to a protected resource that requires admin role and delete authority.");\r\n    }\r\n    @PostMapping("/user/resource")\r\n    @PreAuthorize("hasAuthority(\'CREATE_PRIVILEGE\') and hasRole(\'USER\')")\r\n    public ResponseEntity<String> sayHelloWithRoleUserAndCreateAuthority() {\r\n        return ResponseEntity.ok("Hello, you have access to a protected resource that requires user role and create authority.");\r\n    }\r\n    @PutMapping("/user/resource")\r\n    @PreAuthorize("hasAuthority(\'UPDATE_PRIVILEGE\') and hasRole(\'USER\')")\r\n    public ResponseEntity<String> sayHelloWithRoleUserAndUpdateAuthority() {\r\n        return ResponseEntity.ok("Hello, you have access to a protected resource that requires user role and update authority.");\r\n    }\n'})}),"\n",(0,t.jsxs)(r.p,{children:["L'annotation ",(0,t.jsx)(r.code,{children:"@PreAuthorize"})," est une fonctionnalit\xe9 de Spring Security qui permet de s\xe9curiser l'acc\xe8s aux m\xe9thodes en utilisant des expressions bas\xe9es sur le langage d'expression (SpEL). Cette annotation peut \xeatre appliqu\xe9e au niveau de la m\xe9thode ou au niveau de la classe."]}),"\n",(0,t.jsxs)(r.p,{children:["En utilisant ",(0,t.jsx)(r.code,{children:"@PreAuthorize"}),", vous pouvez sp\xe9cifier les r\xe8gles de s\xe9curit\xe9 qui doivent \xeatre satisfaites pour acc\xe9der \xe0 une m\xe9thode. Les expressions SpEL fournissent une syntaxe expressive pour d\xe9crire les autorisations requises, telles que ",(0,t.jsx)(r.code,{children:"hasAuthority"}),", ",(0,t.jsx)(r.code,{children:"hasRole"}),", ",(0,t.jsx)(r.code,{children:"hasAnyRole"}),", ",(0,t.jsx)(r.code,{children:"hasPermission"}),", etc. Ces expressions peuvent faire r\xe9f\xe9rence aux informations sur l'utilisateur actuellement authentifi\xe9, comme ses r\xf4les, ses autorisations et d'autres attributs."]}),"\n",(0,t.jsxs)(r.p,{children:["L'application de l'annotation ",(0,t.jsx)(r.code,{children:"@PreAuthorize"})," au niveau de la m\xe9thode signifie que la r\xe8gle de s\xe9curit\xe9 s'applique uniquement \xe0 cette m\xe9thode sp\xe9cifique. En revanche, l'application de l'annotation au niveau de la classe signifie que la r\xe8gle de s\xe9curit\xe9 s'applique \xe0 toutes les m\xe9thodes de la classe."]}),"\n",(0,t.jsxs)(r.p,{children:["Pour comprendre comment Spring g\xe8re cela en interne, comme je l'ai d\xe9j\xe0 expliqu\xe9, une fois l'authentification r\xe9ussie, un objet de type ",(0,t.jsx)(r.code,{children:"Authentication"})," est stock\xe9 dans le ",(0,t.jsx)(r.code,{children:"SecurityContext"}),". Comme je vous l'ai \xe9galement montr\xe9 pr\xe9c\xe9demment, cet objet ",(0,t.jsx)(r.code,{children:"Authentication"})," contient les autorit\xe9s de l'utilisateur connect\xe9, c'est-\xe0-dire les informations sur les r\xf4les et les privil\xe8ges qu'il poss\xe8de."]}),"\n",(0,t.jsxs)(r.p,{children:["Le filtre ",(0,t.jsx)(r.code,{children:"AuthorizationFilter"})," est le dernier filtre dans la cha\xeene de filtres de Spring Security. C'est la responsabilit\xe9 de ce filtre d'autoriser ou non l'acc\xe8s aux m\xe9thodes des contr\xf4leurs, ainsi que de bloquer l'acc\xe8s et de lever une exception en cas d'acc\xe8s non autoris\xe9. Le ",(0,t.jsx)(r.code,{children:"AuthorizationFilter"})," intervient apr\xe8s les filtres d'authentification et \xe9value les autorisations n\xe9cessaires en fonction des r\xe8gles de s\xe9curit\xe9 configur\xe9es. Ainsi, il prend une d\xe9cision finale concernant l'autorisation et bloque l'acc\xe8s si n\xe9cessaire."]}),"\n",(0,t.jsxs)(r.p,{children:["Quand une exception d'authentification ",(0,t.jsx)(r.code,{children:"AuthenticationException"}),", le filtre ",(0,t.jsx)(r.code,{children:"ExceptionTranslationFilter"}),"  va lancer l'",(0,t.jsx)(r.code,{children:"AuthenticationEntryPoint"})]}),"\n",(0,t.jsxs)(r.p,{children:["L'impl\xe9mentation par d\xe9faut de l'interface ",(0,t.jsx)(r.code,{children:"AuthenticationEntryPoint"})," dans Spring Security est la classe ",(0,t.jsx)(r.code,{children:"Http403ForbiddenEntryPoint"}),". Cette classe est utilis\xe9e par d\xe9faut pour g\xe9rer les exceptions d'authentification et renvoyer une r\xe9ponse avec le code d'\xe9tat HTTP 403 (Acc\xe8s refus\xe9)."]}),"\n",(0,t.jsxs)(r.p,{children:["La classe ",(0,t.jsx)(r.code,{children:"Http403ForbiddenEntryPoint"})," impl\xe9mente la m\xe9thode ",(0,t.jsx)(r.code,{children:"commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)"})," de l'interface ",(0,t.jsx)(r.code,{children:"AuthenticationEntryPoint"}),". Dans cette m\xe9thode, elle configure la r\xe9ponse HTTP avec le code d'\xe9tat 403 et un message d'erreur standard indiquant l'acc\xe8s refus\xe9."]}),"\n",(0,t.jsxs)(r.p,{children:["Voici la classe ",(0,t.jsx)(r.code,{children:"Http403ForbiddenEntryPoint"})," fournis par Spring"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'public class Http403ForbiddenEntryPoint implements AuthenticationEntryPoint {\r\n\r\n\tprivate static final Log logger = LogFactory.getLog(Http403ForbiddenEntryPoint.class);\r\n\r\n\t/**\r\n\t * Always returns a 403 error code to the client.\r\n\t */\r\n\t@Override\r\n\tpublic void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException arg2)\r\n\t\t\tthrows IOException {\r\n\t\tlogger.debug("Pre-authenticated entry point called. Rejecting access");\r\n\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");\r\n\t}\r\n\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"r\xe9ponses-http--403-forbidden-vs-401-unauthorized",children:"R\xe9ponses HTTP : 403 Forbidden vs 401 Unauthorized"}),"\n",(0,t.jsx)(r.p,{children:"Il y a une distinction importante entre les codes d'\xe9tat HTTP 401 Unauthorized et 403 Forbidden en ce qui concerne les erreurs d'authentification et d'autorisation."}),"\n",(0,t.jsx)(r.p,{children:"Le code 401 Unauthorized est utilis\xe9 pour les erreurs d'authentification, indiquant que l'utilisateur n'est pas correctement authentifi\xe9 ou doit r\xe9essayer l'authentification.  L'utilisateur doit tenter une nouvelle tentative d'authentification pour acc\xe9der \xe0 la ressource demand\xe9e."}),"\n",(0,t.jsx)(r.p,{children:"Le code 403 Forbidden est utilis\xe9 pour les erreurs d'autorisation, indiquant que l'utilisateur est authentifi\xe9, mais n'est pas autoris\xe9 \xe0 acc\xe9der \xe0 la ressource demand\xe9e."}),"\n",(0,t.jsx)(r.p,{children:"Pour r\xe9sumer, si vous recevez une r\xe9ponse avec le code 401, vous pouvez essayer une deuxi\xe8me fois, mais si vous recevez une r\xe9ponse avec le code 403, il est inutile d'insister. L'application vous indique simplement qu'elle vous reconna\xeet, mais que vous n'avez pas les droits d'acc\xe9der \xe0 la ressource, \xe0 moins que vos droits ne changent."}),"\n",(0,t.jsx)(r.h3,{id:"g\xe9rer-les-erreurs-dauthentification-avec-authenticationentrypoint",children:"G\xe9rer les erreurs d'authentification avec AuthenticationEntryPoint"}),"\n",(0,t.jsxs)(r.p,{children:["L'interface ",(0,t.jsx)(r.code,{children:"AuthenticationEntryPoint"})," est utilis\xe9e pour g\xe9rer les erreurs d'authentification  (",(0,t.jsx)(r.code,{children:"AuthenticationException"}),"). Comme je l'ai expliqu\xe9 pr\xe9c\xe9demment, lorsque un utilisateur non authentifi\xe9 tente d'acc\xe9der \xe0 une ressource prot\xe9g\xe9e, l'impl\xe9mentation de ",(0,t.jsx)(r.code,{children:"AuthenticationEntryPoint"})," est invoqu\xe9e pour g\xe9rer cette situation."]}),"\n",(0,t.jsxs)(r.p,{children:["Cr\xe9ez la classe ",(0,t.jsx)(r.code,{children:"Http401UnauthorizedEntryPoint"})," sous le package ",(0,t.jsx)(r.code,{children:"config"})," qui impl\xe9mente ",(0,t.jsx)(r.code,{children:"AuthenticationEntryPoint"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.config;\r\n\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.databind.SerializationFeature;\r\nimport com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\r\nimport fr.mossaab.security.handlers.ErrorResponse;\r\nimport jakarta.servlet.ServletException;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.security.core.AuthenticationException;\r\nimport org.springframework.security.web.AuthenticationEntryPoint;\r\nimport org.springframework.stereotype.Component;\r\n\r\nimport java.io.IOException;\r\nimport java.time.Instant;\r\n\r\n\r\n@Component @Slf4j\r\npublic class Http401UnauthorizedEntryPoint implements AuthenticationEntryPoint {\r\n    @Override\r\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)\r\n            throws IOException, ServletException {\r\n        log.error("Unauthorized error: {}", authException.getMessage());\r\n        response.setContentType(MediaType.APPLICATION_JSON_VALUE);\r\n        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\r\n\r\n        ErrorResponse body = ErrorResponse.builder()\r\n                .status(HttpServletResponse.SC_UNAUTHORIZED)\r\n                .error("Unauthorized")\r\n                .timestamp(Instant.now())\r\n                .message(authException.getMessage())\r\n                .path(request.getServletPath())\r\n                .build();\r\n        final ObjectMapper mapper = new ObjectMapper();\r\n        // register the JavaTimeModule, which enables Jackson to support Java 8 and higher date and time types\r\n        mapper.registerModule(new JavaTimeModule());\r\n        // ask Jackson to serialize dates as strings in the ISO 8601 format\r\n        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false);\r\n        mapper.writeValue(response.getOutputStream(), body);\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["La m\xe9thode ",(0,t.jsx)(r.code,{children:"commence"})," est appel\xe9e lorsque l'authentification \xe9choue et re\xe7oit en param\xe8tres l'objet ",(0,t.jsx)(r.code,{children:"HttpServletRequest"}),", l'objet ",(0,t.jsx)(r.code,{children:"HttpServletResponse"})," et l'exception ",(0,t.jsx)(r.code,{children:"AuthenticationException"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"response.setContentType(MediaType.APPLICATION_JSON_VALUE)"})," et ",(0,t.jsx)(r.code,{children:"response.setStatus(HttpServletResponse.SC_UNAUTHORIZED)"})," configurent la r\xe9ponse HTTP en sp\xe9cifiant le type de contenu comme JSON et le code HTTP comme 401 (Acc\xe8s non autoris\xe9)"]}),"\n",(0,t.jsxs)(r.p,{children:["L'objet ",(0,t.jsx)(r.code,{children:"ErrorResponse"}),"  permet d'encapsuler les d\xe9tails de l'erreur."]}),"\n",(0,t.jsxs)(r.p,{children:["Enfin,  ",(0,t.jsx)(r.code,{children:"ObjectMapper"})," permet de s\xe9rialiser l'objet  ",(0,t.jsx)(r.code,{children:"ErrorResponse"}),"  et l'\xe9crit dans la r\xe9ponse HTTP"]}),"\n",(0,t.jsx)(r.h3,{id:"g\xe9rer-les-erreurs-dautorisation-avec-accessdeniedhandler",children:"G\xe9rer les erreurs d'autorisation avec AccessDeniedHandler"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"AccessDeniedHandler"})," est une interface utilis\xe9e pour g\xe9rer les erreurs d'autorisation. Lorsqu'un utilisateur authentifi\xe9 tente d'acc\xe9der \xe0 une ressource pour laquelle il n'a pas les autorisations requises, nous devons alors fournir une impl\xe9mentation de ",(0,t.jsx)(r.code,{children:"AccessDeniedHandler"})," qui sera invoqu\xe9e pour g\xe9rer cette situation"]}),"\n",(0,t.jsxs)(r.p,{children:["Le handler que nous allons cr\xe9er sera utilis\xe9 par ",(0,t.jsx)(r.code,{children:"ExceptionTranslationFilter"})," pour g\xe9rer une exception de type ",(0,t.jsx)(r.code,{children:"AccessDeniedException"})]}),"\n",(0,t.jsxs)(r.p,{children:["Cr\xe9ez la casse ",(0,t.jsx)(r.code,{children:"CustomAccessDeniedHandler"})," qui impl\xe9mente ",(0,t.jsx)(r.code,{children:"AccessDeniedHandler"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.config;\r\n\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.databind.SerializationFeature;\r\nimport com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\r\nimport fr.mossaab.security.handlers.ErrorResponse;\r\nimport jakarta.servlet.ServletException;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.security.access.AccessDeniedException;\r\nimport org.springframework.security.web.access.AccessDeniedHandler;\r\nimport org.springframework.stereotype.Component;\r\n\r\nimport java.io.IOException;\r\nimport java.time.Instant;\r\n\r\n@Component @Slf4j\r\npublic class CustomAccessDeniedHandler implements AccessDeniedHandler {\r\n    @Override\r\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\r\n        log.error("Access denied error: {}", accessDeniedException.getMessage());\r\n        response.setContentType(MediaType.APPLICATION_JSON_VALUE);\r\n        response.setStatus(HttpServletResponse.SC_FORBIDDEN);\r\n\r\n        ErrorResponse body = ErrorResponse.builder()\r\n                .status(HttpServletResponse.SC_FORBIDDEN)\r\n                .error("Forbidden")\r\n                .timestamp(Instant.now())\r\n                .message(accessDeniedException.getMessage())\r\n                .path(request.getServletPath())\r\n                .build();\r\n        final ObjectMapper mapper = new ObjectMapper();\r\n        mapper.registerModule(new JavaTimeModule());\r\n        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false);\r\n        mapper.writeValue(response.getOutputStream(), body);\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["C'est la m\xeame impl\xe9mentation de ",(0,t.jsx)(r.code,{children:"AuthenticationEntryPoint"}),", la seule diff\xe9rence est que nous avons modifi\xe9 le code HTTP pour passer de 401 \xe0 403."]}),"\n",(0,t.jsx)(r.p,{children:"Maintenant il nous reste de cr\xe9er le filter qui va intercepter les requ\xeates HTTP et essayer d'authentifier l'utilisateur."}),"\n",(0,t.jsx)(r.h3,{id:"filtrer-les-requ\xeates-http",children:"Filtrer les requ\xeates HTTP"}),"\n",(0,t.jsxs)(r.p,{children:["Au d\xe9but, nous avons mentionn\xe9 que les requ\xeates demandant l'acc\xe8s aux ressources prot\xe9g\xe9es doivent \xeatre intercept\xe9es par un filtre personnalis\xe9. Ce filtre tente d'authentifier l'utilisateur en se basant sur le JWT fourni. S'il r\xe9ussit \xe0 authentifier l'utilisateur, il laisse ensuite la main aux autres filtres de la cha\xeene de filtres de Spring Security, tels que le ",(0,t.jsx)(r.code,{children:"AuthorizationFilter"}),", qui prendra la d\xe9cision d'autoriser ou non l'acc\xe8s de l'utilisateur \xe0 la ressource."]}),"\n",(0,t.jsxs)(r.p,{children:["Notre filtre personnalis\xe9 est une classe qui impl\xe9mente ",(0,t.jsx)(r.code,{children:"OncePerRequestFilter"})," qui est une classe abstraite fournie par Spring qui facilite la cr\xe9ation de filtres pour les requ\xeates HTTP. Cette classe garantit que le filtre est ex\xe9cut\xe9 une seule fois pour chaque requ\xeate HTTP entrante."]}),"\n",(0,t.jsxs)(r.p,{children:["Cr\xe9ez la classe ",(0,t.jsx)(r.code,{children:"JwtAuthenticationFilter"})," qui h\xe9rite la classe ",(0,t.jsx)(r.code,{children:"OncePerRequestFilter"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.config;\r\n\r\nimport fr.mossaab.security.service.JwtService;\r\nimport io.micrometer.common.util.StringUtils;\r\nimport jakarta.servlet.FilterChain;\r\nimport jakarta.servlet.ServletException;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.lang.NonNull;\r\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\r\nimport org.springframework.security.core.context.SecurityContext;\r\nimport org.springframework.security.core.context.SecurityContextHolder;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.web.authentication.WebAuthenticationDetailsSource;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.filter.OncePerRequestFilter;\r\nimport java.io.IOException;\r\n\r\n@Component\r\n@RequiredArgsConstructor\r\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\r\n\r\n    private final JwtService jwtService;\r\n    private final UserDetailsService userDetailsService;\r\n\r\n    @Override\r\n    protected void doFilterInternal(\r\n           @NonNull HttpServletRequest request,\r\n           @NonNull HttpServletResponse response,\r\n           @NonNull FilterChain filterChain\r\n    ) throws ServletException, IOException {\r\n        final String authHeader = request.getHeader("Authorization");\r\n        if(authHeader ==  null || !authHeader.startsWith("Bearer ")){\r\n            filterChain.doFilter(request, response);\r\n            return;\r\n        }\r\n        final String jwt = authHeader.substring(7); // after "Bearer "\r\n        final String userEmail =jwtService.extractUserName(jwt);\r\n\r\n        if(StringUtils.isNotEmpty(userEmail)\r\n                && SecurityContextHolder.getContext().getAuthentication() == null){\r\n            UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);\r\n            if(jwtService.isTokenValid(jwt, userDetails)){\r\n                //update the spring security context by adding a new UsernamePasswordAuthenticationToken\r\n                SecurityContext context = SecurityContextHolder.createEmptyContext();\r\n                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(\r\n                        userDetails,\r\n                        null,\r\n                        userDetails.getAuthorities());\r\n                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\r\n                context.setAuthentication(authToken);\r\n                SecurityContextHolder.setContext(context);\r\n            }\r\n        }\r\n        filterChain.doFilter(request,response);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:"Voici une explication d\xe9taill\xe9e du code :"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:'Le filtre v\xe9rifie si le header "Authorization" est pr\xe9sent dans la requ\xeate et commence par "Bearer ". S\'il ne correspond pas \xe0 ces crit\xe8res, le filtre laisse passer la requ\xeate sans aucune modification.'}),"\n",(0,t.jsx)(r.li,{children:'Si le header "Authorization" est pr\xe9sent et correspond au format "Bearer ", le filtre extrait le JWT de la cha\xeene du header.'}),"\n",(0,t.jsxs)(r.li,{children:["\xc0 l'aide du service ",(0,t.jsx)(r.code,{children:"JwtService"}),", le filtre extrait le username (email) \xe0 partir du JWT."]}),"\n",(0,t.jsxs)(r.li,{children:["Ensuite, le filtre v\xe9rifie si le username n'est pas vide et si l'authentification n'a pas d\xe9j\xe0 \xe9t\xe9 effectu\xe9e pour cette requ\xeate. Si ces conditions sont remplies, le filtre demande au service ",(0,t.jsx)(r.code,{children:"userDetailsService"})," de charger les d\xe9tails de l'utilisateur correspondant au nom d'utilisateur."]}),"\n",(0,t.jsxs)(r.li,{children:["Si le service ",(0,t.jsx)(r.code,{children:"userDetailsService"})," ne parvient pas \xe0 trouver l'utilisateur, une exception sera lev\xe9e."]}),"\n",(0,t.jsxs)(r.li,{children:["Le filtre utilise ensuite le service ",(0,t.jsx)(r.code,{children:"JwtService"})," pour valider le JWT en le comparant aux d\xe9tails de l'utilisateur charg\xe9s pr\xe9c\xe9demment."]}),"\n",(0,t.jsxs)(r.li,{children:["Si le JWT est valide, le filtre met \xe0 jour le contexte de s\xe9curit\xe9 de Spring en ajoutant une instance de ",(0,t.jsx)(r.code,{children:"UsernamePasswordAuthenticationToken"})," contenant les d\xe9tails de l'utilisateur authentifi\xe9."]}),"\n",(0,t.jsxs)(r.li,{children:["Finalement, le filtre passe la requ\xeate au filtre suivant dans la cha\xeene de filtres en appelant ",(0,t.jsx)(r.code,{children:"filterChain.doFilter(request, response)"}),"."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Il nous reste la derni\xe8re \xe9tape avant de tester c'est la configuration de Spring Security"}),"\n",(0,t.jsx)(r.h3,{id:"configuration-de-spring-security",children:"Configuration de Spring Security"}),"\n",(0,t.jsxs)(r.p,{children:["Sous le package config, commencez par cr\xe9er une classe ",(0,t.jsx)(r.code,{children:"ApplicationSecurityConfig"})," et ajouter l'annotation ",(0,t.jsx)(r.code,{children:"@Configuration"})," pour indiquer \xe0 Spring que c'est une classe de configuration."]}),"\n",(0,t.jsx)(r.p,{children:"Les beans requis sont les suivants :"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["Une impl\xe9mentation de ",(0,t.jsx)(r.code,{children:"UserDetailsService"}),", notamment de la m\xe9thode ",(0,t.jsx)(r.code,{children:"loadByUsername"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:["Une impl\xe9mentation de ",(0,t.jsx)(r.code,{children:"PasswordEncoder"}),", par exemple ",(0,t.jsx)(r.code,{children:"BCryptPasswordEncoder"})," utilis\xe9 par d\xe9faut."]}),"\n",(0,t.jsxs)(r.li,{children:["L'",(0,t.jsx)(r.code,{children:"AuthenticationProvider"})," utilisant ",(0,t.jsx)(r.code,{children:"DaoAuthenticationProvider"})," avec l'impl\xe9mentation de ",(0,t.jsx)(r.code,{children:"UserDetailsService"})," et ",(0,t.jsx)(r.code,{children:"PasswordEncoder"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:["L'",(0,t.jsx)(r.code,{children:"AuthenticationManager"})," obtenu \xe0 partir de ",(0,t.jsx)(r.code,{children:"AuthenticationConfiguration"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Voici la classe ",(0,t.jsx)(r.code,{children:"ApplicationSecurityConfig"})," :"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.config;\r\n\r\nimport fr.mossaab.security.repository.UserRepository;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.security.authentication.AuthenticationManager;\r\nimport org.springframework.security.authentication.AuthenticationProvider;\r\nimport org.springframework.security.authentication.dao.DaoAuthenticationProvider;\r\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\r\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\n\r\n@Configuration\r\n@RequiredArgsConstructor\r\npublic class ApplicationSecurityConfig {\r\n    private final UserRepository userRepository;\r\n\r\n    @Bean\r\n    public UserDetailsService userDetailsService(){\r\n        return username -> userRepository.findByEmail(username)\r\n                .orElseThrow(()-> new UsernameNotFoundException("User not found"));\r\n    }\r\n\r\n    @Bean\r\n    public AuthenticationProvider authenticationProvider() {\r\n        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();\r\n        authProvider.setUserDetailsService(userDetailsService());\r\n        authProvider.setPasswordEncoder(passwordEncoder());\r\n        return authProvider;\r\n    }\r\n\r\n    @Bean\r\n    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {\r\n        return config.getAuthenticationManager();\r\n    }\r\n\r\n    @Bean\r\n    public PasswordEncoder passwordEncoder() {\r\n        return new BCryptPasswordEncoder();\r\n    }\r\n\r\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["Nous allons maintenant cr\xe9er la classe ",(0,t.jsx)(r.code,{children:"SecurityConfiguration"})," qui responsable de configurer les r\xe8gles de s\xe9curit\xe9 pour les requ\xeates HTTP et sp\xe9cifier les filtres et les gestionnaires n\xe9cessaires pour l'authentification et les autorisations dans notre application. Elle d\xe9finit \xe9galement les r\xe8gles d'autorisation pour les ressources de l'API"]}),"\n",(0,t.jsxs)(r.p,{children:["Dans cette classe, nous devons fournir le bean ",(0,t.jsx)(r.code,{children:"SecurityFilterChain"}),", comme je l'ai expliqu\xe9 et mentionn\xe9 dans le diagramme d'architecture de Spring au d\xe9but de cet article."]}),"\n",(0,t.jsxs)(r.p,{children:["Cr\xe9ez la classe ",(0,t.jsx)(r.code,{children:"SecurityConfiguration"})," avec une m\xe9thode ",(0,t.jsx)(r.code,{children:"securityFilterChain"})," qui prend en param\xe8tre ",(0,t.jsx)(r.code,{children:"HttpSecurity"})," et renvoie le bean ",(0,t.jsx)(r.code,{children:"SecurityFilterChain"}),"."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'package fr.mossaab.security.config;\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.http.HttpMethod;\r\nimport org.springframework.security.authentication.AuthenticationProvider;\r\nimport org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;\r\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\r\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\r\nimport org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;\r\nimport org.springframework.security.web.SecurityFilterChain;\r\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\r\nimport static org.springframework.security.config.http.SessionCreationPolicy.STATELESS;\r\n\r\n@Configuration\r\n@EnableWebSecurity\r\n@RequiredArgsConstructor\r\n@EnableMethodSecurity\r\npublic class SecurityConfiguration {\r\n\r\n    private final JwtAuthenticationFilter jwtAuthenticationFilter;\r\n    private final AuthenticationProvider authenticationProvider;\r\n    private final Http401UnauthorizedEntryPoint unauthorizedEntryPoint;\r\n    private final CustomAccessDeniedHandler accessDeniedHandler;\r\n    \r\n    @Bean\r\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\r\n        http.csrf(AbstractHttpConfigurer::disable)\r\n                .exceptionHandling(exception -> exception\r\n                        .authenticationEntryPoint(unauthorizedEntryPoint)\r\n                        .accessDeniedHandler(accessDeniedHandler))\r\n                .authorizeHttpRequests(request ->\r\n                        request\r\n                                .requestMatchers(\r\n                                        "/api/v1/auth/**"\r\n                                ).permitAll()\r\n                               //.requestMatchers("/api/v1/admin/resource").hasRole("ADMIN") replaced with annotation in AuthorizationController      \r\n                                .anyRequest().authenticated())\r\n                .sessionManagement(manager -> manager.sessionCreationPolicy(STATELESS))\r\n                .authenticationProvider(authenticationProvider).addFilterBefore(\r\n                        jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);\r\n        return http.build();\r\n    }\r\n}\r\n\n'})}),"\n",(0,t.jsxs)(r.p,{children:["Voici une explique de la m\xe9thode",(0,t.jsx)(r.code,{children:"securityFilterChain()"})," :"]}),"\n",(0,t.jsxs)(r.p,{children:["Cette m\xe9thode cr\xe9e un bean ",(0,t.jsx)(r.code,{children:"SecurityFilterChain"})," qui d\xe9finit les r\xe8gles de s\xe9curit\xe9 pour les requ\xeates HTTP. Elle utilise la m\xe9thode de configuration ",(0,t.jsx)(r.code,{children:"http"})," pour sp\xe9cifier les autorisations d'acc\xe8s aux ressources."]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"csrf(AbstractHttpConfigurer::disable)"}),": D\xe9sactive la protection CSRF. Comme expliqu\xe9 pr\xe9c\xe9demment, en mode Stateless, cette protection est inutile dans notre cas."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"exceptionHandling()"}),": G\xe8re les exceptions li\xe9es \xe0 l'authentification et aux autorisations. Ici, nous avons sp\xe9cifi\xe9 les deux impl\xe9mentations que nous avons cr\xe9\xe9es, ",(0,t.jsx)(r.code,{children:"CustomAccessDeniedHandler"})," et ",(0,t.jsx)(r.code,{children:"Http401UnauthorizedEntryPoint"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"authorizeHttpRequests()"}),": D\xe9finit les r\xe8gles d'autorisation pour les requ\xeates HTTP. Dans notre cas, l'acc\xe8s est autoris\xe9 pour les requ\xeates vers \"/api/v1/auth/**\", qui est le chemin d'acc\xe8s vers notre contr\xf4leur d'authentification, et n\xe9cessite une authentification pour toutes les autres requ\xeates."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"sessionManagement()"}),": D\xe9finit la gestion des sessions en mode Stateless, o\xf9 la cr\xe9ation de session est d\xe9sactiv\xe9e."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"authenticationProvider()"}),": Sp\xe9cifie l'",(0,t.jsx)(r.code,{children:"AuthenticationProvider"})," utilis\xe9 pour l'authentification, fourni par notre classe ",(0,t.jsx)(r.code,{children:"ApplicationSecurityConfig"})," que nous venons de cr\xe9er."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"addFilterBefore()"}),": Ajoute notre filtre personnalis\xe9 ",(0,t.jsx)(r.code,{children:"JwtAuthenticationFilter"})," avant le ",(0,t.jsx)(r.code,{children:"UsernamePasswordAuthenticationFilter"})," pour g\xe9rer l'authentification bas\xe9e sur le JWT."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Ces configurations permettent de d\xe9finir les r\xe8gles de s\xe9curit\xe9 de notre application Spring Security en d\xe9sactivant CSRF, g\xe9rant les exceptions, sp\xe9cifiant les autorisations d'acc\xe8s et la gestion des sessions, ainsi que l'ajout de notre filtre personnalis\xe9 pour l'authentification bas\xe9e sur le JWT."}),"\n",(0,t.jsxs)(r.p,{children:["Les r\xe8gles d'autorisation sont g\xe9r\xe9es \xe0 l'aide des annotations directement au niveau des contr\xf4leurs, c'est pourquoi nous avons ajout\xe9 l'annotation ",(0,t.jsx)(r.code,{children:"@EnableMethodSecurity"}),". Cependant, vous avez \xe9galement la possibilit\xe9 de g\xe9rer les autorisations de mani\xe8re globale dans le bean ",(0,t.jsx)(r.code,{children:"SecurityFilterChain"})," en utilisant les ",(0,t.jsx)(r.code,{children:"requestMatchers"}),'. Par exemple, vous pouvez sp\xe9cifier que l\'acc\xe8s \xe0 "/api/v1/admin/resource" n\xe9cessite le r\xf4le "ADMIN" avec ',(0,t.jsx)(r.code,{children:'.requestMatchers("/api/v1/admin/resource").hasRole("ADMIN")'}),". De m\xeame, vous pouvez autoriser uniquement la m\xe9thode HTTP POST sur certaines URL en utilisant ",(0,t.jsx)(r.code,{children:'.requestMatchers(HttpMethod.POST,"/api/v1/admin/resource").hasRole("ADMIN")'}),". Cette approche vous permet de g\xe9rer les autorisations de mani\xe8re plus granulaire en sp\xe9cifiant les URL et les m\xe9thodes HTTP associ\xe9es aux autorisations requises."]}),"\n",(0,t.jsx)(r.p,{children:"Il est important de noter que Spring Security offre de nombreuses possibilit\xe9s de personnalisation. Je vous encourage \xe0 explorer la documentation officielle pour en savoir plus. Cependant, la configuration que nous avons mise en place est suffisante pour notre API."}),"\n",(0,t.jsx)(r.h2,{id:"d\xe9monstration-de-lapplication",children:"D\xe9monstration de l'application"}),"\n",(0,t.jsxs)(r.p,{children:["Avant de tester l'application, voici notre fichier ",(0,t.jsx)(r.code,{children:"application.yml"})," (vous pouvez \xe9galement utiliser ",(0,t.jsx)(r.code,{children:"application.properties"}),") :"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-yml",children:"spring:\r\n  datasource:\r\n    driver-class-name: org.postgresql.Driver\r\n    url: jdbc:postgresql://localhost:5432/db_security\r\n    username: postgres\r\n    password: ${POSTGRES_PASSWORD}\r\n  jpa:\r\n    hibernate:\r\n      ddl-auto: create\r\n    show-sql: true\r\n    properties:\r\n      hibernate:\r\n        format_sql: true\r\n    database: postgresql\r\n    database-platform: org.hibernate.dialect.PostgreSQLDialect\r\nserver:\r\n  port: 8086\r\napplication:\r\n  security:\r\n    jwt:\r\n      secret-key: 586B633834416E396D7436753879382F423F4428482B4C6250655367566B5970\r\n      expiration: 86400000 # a day\r\n      refresh-token:\r\n        expiration: 604800000 # 7 days\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Nous allons maintenant tester l'acc\xe8s \xe0 notre application en utilisant  ",(0,t.jsx)(r.code,{children:"Postman"})," qui est une application permettant de tester des API"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"L'ajout de deux utilisateurs, l'un avec le r\xf4le USER et l'autre avec le r\xf4le ADMIN"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"admin-register",src:n(7302).Z+"",width:"842",height:"715"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"register",src:n(5709).Z+"",width:"738",height:"680"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"L'authentification d'un utilisateur"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"user_auth",src:n(8456).Z+"",width:"743",height:"610"})}),"\n",(0,t.jsx)(r.p,{children:"**\xc9chec de l'authentification **"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"invalid-email",src:n(5803).Z+"",width:"626",height:"605"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"L'acc\xe8s \xe0 une ressource prot\xe9g\xe9e qui n\xe9cessite un JWT valide"})}),"\n",(0,t.jsx)(r.p,{children:"L'utilisateur doit avoir le r\xf4le admin avec le droit de lecture :"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"admin-access-protected",src:n(2552).Z+"",width:"842",height:"434"})}),"\n",(0,t.jsx)(r.p,{children:"Si nous essayons d'acc\xe9der \xe0 la m\xeame ressource, mais cette fois avec le JWT de l'utilisateur ayant le r\xf4le USER :"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"forbidden-user-admin",src:n(8126).Z+"",width:"843",height:"535"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"L'acc\xe8s L'acc\xe8s \xe0 une ressource prot\xe9g\xe9e avec un JWT expir\xe9 :"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"user-jwt-expired",src:n(4632).Z+"",width:"835",height:"531"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Demander un nouveau JWT \xe0 partir d'un refreshToken valide :"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"user-refreshtoken",src:n(3225).Z+"",width:"841",height:"548"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Demander un nouveau JWT \xe0 partir d'un refreshToken invalide :"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"invalidRefreshToken",src:n(3093).Z+"",width:"844",height:"555"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Demander un nouveau JWT \xe0 partir d'un refreshToken expir\xe9 :"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.img,{alt:"expired-refreshtoken",src:n(7158).Z+"",width:"844",height:"598"})}),"\n",(0,t.jsx)(r.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(r.p,{children:"Cet article nous a pr\xe9sent\xe9 l'utilisation de Spring Security pour s\xe9curiser une application Spring Boot. Nous avons explor\xe9 divers concepts tels que l'authentification, l'autorisation et l'utilisation de JWT. Gr\xe2ce \xe0 Spring Security, nous avons pu mettre en place une couche de s\xe9curit\xe9 robuste pour prot\xe9ger nos ressources et g\xe9rer les droits d'acc\xe8s des utilisateurs."}),"\n",(0,t.jsxs)(r.p,{children:["Le code complet de l'impl\xe9mentation pr\xe9sent\xe9e dans cet article est disponible sur ",(0,t.jsx)(r.a,{href:"https://github.com/MossaabFrifita/spring-boot-3-security-6-jwt",children:"GitHub"})]}),"\n",(0,t.jsx)(r.p,{children:"En utilisant les principes de Spring Security et en comprenant ses fonctionnalit\xe9s cl\xe9s, vous pouvez renforcer la s\xe9curit\xe9 de votre application et prot\xe9ger les ressources sensibles contre les acc\xe8s non autoris\xe9s."}),"\n",(0,t.jsx)(r.p,{children:"N'oubliez pas de toujours garder \xe0 l'esprit les meilleures pratiques de s\xe9curit\xe9 lors du d\xe9veloppement d'applications et de continuer \xe0 vous informer sur les nouvelles tendances et les mises \xe0 jour de Spring Security pour maintenir votre application s\xe9curis\xe9e."}),"\n",(0,t.jsx)(r.p,{children:"Soyez assur\xe9 que Spring Security offre une solution puissante et flexible pour r\xe9pondre \xe0 vos besoins de s\xe9curit\xe9, et il reste un choix populaire pour s\xe9curiser les applications bas\xe9es sur Spring Boot."})]})}function d(e={}){const{wrapper:r}={...(0,i.a)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},2552:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/admin-access-protected-da088384de62cdd5c6c696f1ec8dab78.PNG"},7302:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/admin-register-617bf0d4fefc0a68804bf1aa948c0931.PNG"},6687:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/authManager.drawio-cd56a74d3e9c2530c02cc50274c6f810.png"},7278:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/bCrypt-eb033901ba6502c8bef94b09fef06530.PNG"},7158:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/expired-refreshtoken-a5db229a0ad2ad207576097a8d3fdc20.PNG"},8126:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/forbidden-user-admin-25e7ff246ae0a0efaa6be11238b75ed7.png"},8699:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/image-20230716224835601-64e04e4b81d22e0af4e6a80484e75c8e.png"},5803:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/invalid-email-44f5c37bbd481a4e6f58063daac0c4e5.PNG"},3093:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/invalidRefreshToken-0d6be915a34847c31d1b95cb6390b816.PNG"},5709:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/register-cb2c100fa1454dfb6e392c188a79414d.PNG"},9664:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/springAuthAut.drawio-4a7453b06274a82066c0d2bc75154bdf.png"},6424:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/springSecuirtyArch.drawio-b74e1f8a2cb220b91bef787bf7b05641.png"},4632:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/user-jwt-expired-c4fbf4991963f4e648cabf1844b34dc9.PNG"},3225:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/user-refreshtoken-4dc9c5b900818dd1e501bfa6a22e8f54.PNG"},8456:(e,r,n)=>{n.d(r,{Z:()=>t});const t=n.p+"assets/images/user_auth-413adee9bb1bf09d8026a0d46eae26af.PNG"},1151:(e,r,n)=>{n.d(r,{Z:()=>a,a:()=>o});var t=n(7294);const i={},s=t.createContext(i);function o(e){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);